From d3dbb89c98448d759afb9bef9ecd8711399c56cf Mon Sep 17 00:00:00 2001
From: Ning Sun <ning.sun@intel.com>
Date: Wed, 14 Oct 2015 11:37:57 -0700
Subject: 1. Mitigated S3 resume delay by adjusting LZ_MAX_OFFSET to 5000 in lz.c.

2. Enhanced the manipulation of tboot log by modifying/adding new fields
   in tboot_log_t. As tboot log buffer is limited to 32k, it will be
   flushed with new logs after whole buffer is packed with compressed
   logs.

Signed-off-by Ning Sun <ning.sun@intel.com>
---
 include/tboot.h       |   12 +++++-----
 tboot/common/lz.c     |    2 +-
 tboot/common/printk.c |   60 +++++++++++++++++++++++++++++++------------------
 utils/txt-stat.c      |   33 +++++++++++++++-----------
 4 files changed, 64 insertions(+), 43 deletions(-)

diff --git a/include/tboot.h b/include/tboot.h
index d10fcf8..abb1ca4 100644
--- a/include/tboot.h
+++ b/include/tboot.h
@@ -33,7 +33,6 @@
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */
-
 #ifndef __TBOOT_H__
 #define __TBOOT_H__
 
@@ -129,13 +128,14 @@ typedef struct __packed {
 /*
  * used to log tboot printk output
  */
-
+#define ZIP_COUNT_MAX 10
 typedef struct {
     uuid_t     uuid;
-    uint32_t   max_size;
-    uint32_t   curr_pos;
-    uint32_t   zip_pos;
-    uint32_t   zip_size;
+    uint16_t   max_size;
+    uint16_t   curr_pos;
+    uint16_t   zip_pos[ZIP_COUNT_MAX];
+    uint16_t   zip_size[ZIP_COUNT_MAX];
+    uint8_t    zip_count;
     char       buf[];
 } tboot_log_t;
 
diff --git a/tboot/common/lz.c b/tboot/common/lz.c
index b6c2fdb..a59c2f8 100644
--- a/tboot/common/lz.c
+++ b/tboot/common/lz.c
@@ -86,7 +86,7 @@
    compression, while higher values gives better compression. The default
    value of 100000 is quite high. Experiment to see what works best for
    you. */
-#define LZ_MAX_OFFSET 100000
+#define LZ_MAX_OFFSET 5000
 
 
 
diff --git a/tboot/common/printk.c b/tboot/common/printk.c
index 3ca4f55..df049dd 100644
--- a/tboot/common/printk.c
+++ b/tboot/common/printk.c
@@ -59,13 +59,16 @@ __data tboot_log_t *g_log = NULL;
 
 static void memlog_init(void)
 {
-        if ( g_log == NULL ) {
-        g_log = (tboot_log_t *)TBOOT_SERIAL_LOG_ADDR;
-        g_log->uuid = (uuid_t)TBOOT_LOG_UUID;
-        g_log->curr_pos = 0;
-        g_log->zip_pos = 0;
-        g_log->zip_size = 0;
-        }
+
+
+   if ( g_log == NULL ) {
+       g_log = (tboot_log_t *)TBOOT_SERIAL_LOG_ADDR;
+       g_log->uuid = (uuid_t)TBOOT_LOG_UUID;
+       g_log->curr_pos = 0;
+       g_log->zip_count = 0;
+       for ( uint8_t i = 0; i < ZIP_COUNT_MAX; i++ ) g_log->zip_pos[i] = 0;
+       for ( uint8_t i = 0; i < ZIP_COUNT_MAX; i++ ) g_log->zip_size[i] = 0;
+       }
 
     /* initialize these post-launch as well, since bad/malicious values */
     /* could compromise environment */
@@ -73,12 +76,14 @@ static void memlog_init(void)
     g_log->max_size = TBOOT_SERIAL_LOG_SIZE - sizeof(*g_log);
 
     /* if we're calling this post-launch, verify that curr_pos is valid */
-    if ( g_log->zip_pos > g_log->max_size ){
-        g_log->zip_pos = 0;
+    if ( g_log->zip_pos[g_log->zip_count] > g_log->max_size ){
         g_log->curr_pos = 0;
+        g_log->zip_count = 0;
+        for ( uint8_t i = 0; i < ZIP_COUNT_MAX; i++ ) g_log->zip_pos[i] = 0;
+        for ( uint8_t i = 0; i < ZIP_COUNT_MAX; i++ ) g_log->zip_size[i] = 0;
     }
     if ( g_log->curr_pos > g_log->max_size )
-        g_log->curr_pos = g_log->zip_pos;
+        g_log->curr_pos = g_log->zip_pos[g_log->zip_count];
 }
 
 static void memlog_write( const char *str, unsigned int count)
@@ -86,24 +91,35 @@ static void memlog_write( const char *str, unsigned int count)
     /* allocate a 32K temp buffer for compressed log  */
     static char buf[32*1024];
     char *out=buf;
+    uint32_t zip_size;
 
     if ( g_log == NULL || count > g_log->max_size )
         return;
 
-    /* do a compression of the log if curr_pos + count > max_size  */
+  /* do a compression of the log if curr_pos + count > max_size  */
     if (g_log->curr_pos + count > g_log->max_size) {
-       g_log->zip_size = LZ_Compress(&g_log->buf[g_log->zip_pos], out, g_log->curr_pos - g_log->zip_pos);
-       memcpy(&g_log->buf[g_log->zip_pos], out, g_log->zip_size); 
-       g_log->zip_pos += g_log->zip_size;
-       g_log->curr_pos = g_log->zip_pos;
-       if ( g_log->buf[g_log->zip_pos - 1] !='0')
-          g_log->buf[g_log->zip_pos] = '0';
-       else {
-          g_log->zip_pos--;
-          g_log->curr_pos--;
-       } 
-           
+        zip_size = LZ_Compress(&g_log->buf[g_log->zip_pos[g_log->zip_count]], out, g_log->curr_pos - g_log->zip_pos[g_log->zip_count]);
+        if ((g_log->zip_pos[g_log->zip_count] + zip_size + count < g_log->max_size) && (g_log->zip_count < ZIP_COUNT_MAX)) {
+            memcpy(&g_log->buf[g_log->zip_pos[g_log->zip_count]], out, zip_size);
+            g_log->zip_size[g_log->zip_count] = zip_size;
+            g_log->zip_count++;
+            g_log->zip_pos[g_log->zip_count] = g_log->zip_pos[g_log->zip_count - 1] + zip_size;
+            g_log->curr_pos = g_log->zip_pos[g_log->zip_count];
+            if (g_log->buf[g_log->zip_pos[g_log->zip_count] - 1] !='\0')
+                g_log->buf[g_log->zip_pos[g_log->zip_count]] = '\0';
+            else {
+                  g_log->zip_pos[g_log->zip_count]--;
+                  g_log->curr_pos--;
+            }
+        }
+        else {
+              g_log->curr_pos = 0;
+              for ( uint8_t i = 0; i < ZIP_COUNT_MAX; i++ ) g_log->zip_pos[i] = 0;
+              for ( uint8_t i = 0; i < ZIP_COUNT_MAX; i++ ) g_log->zip_size[i] = 0;
+              g_log->zip_count = 0;
+        }
     }
+
     memcpy(&g_log->buf[g_log->curr_pos], str, count);
     g_log->curr_pos += count; 
 
diff --git a/utils/txt-stat.c b/utils/txt-stat.c
index a449947..37a2953 100644
--- a/utils/txt-stat.c
+++ b/utils/txt-stat.c
@@ -221,7 +221,7 @@ static void display_tboot_log(void *log_base)
     char *out = pbuf;
     tboot_log_t *log = (tboot_log_t *)log_base;
     char *log_buf = log->buf;
-
+    uint8_t i = 0;
     if ( !are_uuids_equal(&(log->uuid), &((uuid_t)TBOOT_LOG_UUID)) ) {
         printf("unable to find TBOOT log\n");
         return;
@@ -229,27 +229,32 @@ static void display_tboot_log(void *log_base)
 
     printf("TBOOT log:\n");
     printf("\t max_size=%d\n", log->max_size);
-    printf("\t zip_pos=%d\n", log->zip_pos);
-    printf("\t zip_size=%d\n", log->zip_size);
+    printf("\t zip_count=%d\n", log->zip_count);
+    while ( i < log->zip_count) {
+        printf("\t zip_pos[%d] = %d\n", i, log->zip_pos[i]);
+        printf("\t zip_size[%d] = %d\n", i, log->zip_size[i]);
+          i++;
+    }
+    
     printf("\t curr_pos=%d\n", log->curr_pos);
     printf("\t buf:\n");
     /* log->buf is phys addr of buf, which will not match where mmap has */
     /* map'ed us, but since it is always just past end of struct, use that */
     /* to uncompress tboot log */ 
-    if (log->zip_size > 0) {
-        LZ_Uncompress(log_buf, out, log->zip_size);
-        /* log is too big for single printk(), so break it up */
-        /* print out the uncompressed log */
-        for ( unsigned int curr_pos = 0; curr_pos < 32*1024; 
-            curr_pos += sizeof(buf)-1 ) {
-            strncpy(buf, out + curr_pos, sizeof(buf)-1);
-            buf[sizeof(buf)-1] = '\0';
-            printf("%s", buf);
+    if (log->zip_count > 0) {
+        for ( i = 0; i< log->zip_count; i++) {
+            LZ_Uncompress(&log_buf[log->zip_pos[i]], out, log->zip_size[i]);
+            /* log is too big for single printk(), so break it up */
+            /* print out the uncompressed log */
+            for ( unsigned int curr_pos = 0; curr_pos < 32*1024; curr_pos += sizeof(buf)-1 ) {
+                strncpy(buf, out + curr_pos, sizeof(buf)-1);
+                buf[sizeof(buf)-1] = '\0';
+                printf("%s", buf);
+            }
         }
     } 
 
-    for ( unsigned int curr_pos = log->zip_pos; curr_pos < log->curr_pos;
-          curr_pos += sizeof(buf)-1 ) {
+    for ( unsigned int curr_pos = log->zip_pos[log->zip_count]; curr_pos < log->curr_pos; curr_pos += sizeof(buf)-1 ) {
         strncpy(buf, log_buf + curr_pos, sizeof(buf)-1);
         buf[sizeof(buf)-1] = '\0';
         printf("%s", buf);
-- 
1.7.1

