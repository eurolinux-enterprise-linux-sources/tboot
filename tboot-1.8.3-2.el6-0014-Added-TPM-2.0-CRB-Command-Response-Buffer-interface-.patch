From dd669269276eec5939d36148dfce170243370c76 Mon Sep 17 00:00:00 2001
From: Ning Sun <ning.sun@intel.com>
Date: Tue, 23 Feb 2016 10:55:40 -0800
Subject: Added TPM 2.0 CRB(Command Response Buffer) interface support.

Reference: 1. TCG PC Client Platform TPM Profile (PTP) Specification,
	Family "2.0" Level 00 Revision 00.43:
	http://www.trustedcomputinggroup.org/files/static_page_files/28CBF489-1A4B-B294-D038AC358AD39A6A/PC%20Client%20Specific%20Platform%20TPM%20Profile%20for%20TPM%202%200%20v43%20150126.pdf

Signed-off-by Ning Sun <ning.sun@intel.com>
---
 COPYING                    |    2 +-
 include/tb_policy.h        |    3 +-
 tboot/common/cmdline.c     |    7 +-
 tboot/common/elf.c         |    2 +-
 tboot/common/integrity.c   |   32 +--
 tboot/common/tboot.c       |   75 +++----
 tboot/common/tpm.c         |  564 ++++++++++++++++++++++++++++++++++----------
 tboot/common/tpm_12.c      |   18 +-
 tboot/common/tpm_20.c      |  329 ++++++++++++++------------
 tboot/include/tpm.h        |  294 ++++++++++++++++++++---
 tboot/include/tpm_20.h     |   15 +-
 tboot/include/txt/acmod.h  |    2 +-
 tboot/txt/acmod.c          |    3 +-
 tboot/txt/txt.c            |   31 ++-
 14 files changed, 955 insertions(+), 422 deletions(-)
 mode change 100755 => 100644 tboot/common/pci_cfgreg.c
 mode change 100755 => 100644 tboot/include/pci_cfgreg.h
 mode change 100755 => 100644 tboot/include/vga.h

diff --git a/COPYING b/COPYING
index b0a6872..7a44aac 100644
--- a/COPYING
+++ b/COPYING
@@ -1,3 +1,3 @@
 Files which do not contain any copyright information are assumed to be
-copyrighted by Intel Corporation.  All other files contain their copyright and
+copyrighted by Intel Corporation. All other files contain their copyright and
 license at the beginning of the file.
diff --git a/include/tb_policy.h b/include/tb_policy.h
index fb92c7d..118a735 100644
--- a/include/tb_policy.h
+++ b/include/tb_policy.h
@@ -257,8 +257,7 @@ static inline tb_policy_entry_t* find_policy_entry(const tb_policy_t *policy,
 /*
  * verify and display policy
  */
-static inline bool verify_policy(const tb_policy_t *policy, size_t size,
-                                 bool print)
+static inline bool verify_policy(const tb_policy_t *policy, size_t size, bool print)
 {
     if ( print ) PRINT(TBOOT_DETA"policy:\n");
 
diff --git a/tboot/common/cmdline.c b/tboot/common/cmdline.c
index 6d22665..7a037fd 100644
--- a/tboot/common/cmdline.c
+++ b/tboot/common/cmdline.c
@@ -110,9 +110,7 @@ static const tb_loglvl_map_t g_loglvl_map[] = {
     { "all",   TBOOT_LOG_LEVEL_ALL   },
 };
 
-static const char* get_option_val(const cmdline_option_t *options,
-                                  char vals[][MAX_VALUE_LEN],
-                                  const char *opt_name)
+static const char* get_option_val(const cmdline_option_t *options,  char vals[][MAX_VALUE_LEN],    const char *opt_name)
 {
     for ( int i = 0; options[i].name != NULL; i++ ) {
         if ( strcmp(options[i].name, opt_name) == 0 )
@@ -504,8 +502,7 @@ bool get_tboot_measure_nv(void)
 
 void get_tboot_extpol(void)
 {
-    const char *extpol = get_option_val(g_tboot_cmdline_options,
-                                       g_tboot_param_values, "extpol");
+    const char *extpol = get_option_val(g_tboot_cmdline_options,  g_tboot_param_values, "extpol");
 
     if ( extpol == NULL ) {
         g_tpm->extpol = TB_EXTPOL_FIXED;
diff --git a/tboot/common/elf.c b/tboot/common/elf.c
index 9a15944..5d40d7b 100644
--- a/tboot/common/elf.c
+++ b/tboot/common/elf.c
@@ -68,7 +68,7 @@ bool is_elf_image(const void *image, size_t size)
          (elf->e_ident[EI_MAG1] != ELFMAG1) ||
          (elf->e_ident[EI_MAG2] != ELFMAG2) ||
          (elf->e_ident[EI_MAG3] != ELFMAG3) ) {
-        printk(TBOOT_WARN"Error: ELF magic number is not matched.\n");
+        printk(TBOOT_WARN"ELF magic number is not matched, image is not ELF format.\n");
         return false;
     }
     /* check data encoding in ELF */
diff --git a/tboot/common/integrity.c b/tboot/common/integrity.c
index 5357713..2c07ec9 100644
--- a/tboot/common/integrity.c
+++ b/tboot/common/integrity.c
@@ -133,9 +133,7 @@ static void print_post_k_s3_state(void)
               sizeof(g_post_k_s3_state.kernel_integ));
 }
 
-static bool seal_data(const void *data, size_t data_size,
-                   const void *secrets, size_t secrets_size,
-                   uint8_t *sealed_data, uint32_t *sealed_data_size)
+static bool seal_data(const void *data, size_t data_size, const void *secrets, size_t secrets_size, uint8_t *sealed_data, uint32_t *sealed_data_size)
 {
     /* TPM_Seal can only seal small data (like key or hash), so hash data */
     struct __packed {
@@ -150,14 +148,10 @@ static bool seal_data(const void *data, size_t data_size,
         return false;
     }
 
-    if ( secrets != NULL && secrets_size > 0 )
-        memcpy(blob.secrets, secrets, secrets_size);
+    if ( secrets != NULL && secrets_size > 0 )  memcpy(blob.secrets, secrets, secrets_size);
 
-    err = g_tpm->seal(g_tpm, 2,
-                   sizeof(blob), (const uint8_t *)&blob,
-                   sealed_data_size, sealed_data);
-    if ( !err )
-        printk(TBOOT_WARN"failed to seal data\n");
+    err = g_tpm->seal(g_tpm, 2, sizeof(blob), (const uint8_t *)&blob, sealed_data_size, sealed_data);
+    if ( !err )  printk(TBOOT_WARN"failed to seal data\n");
 
     /* since blob might contain secret, clear it */
     memset(&blob, 0, sizeof(blob));
@@ -165,10 +159,7 @@ static bool seal_data(const void *data, size_t data_size,
     return err;
 }
 
-static bool verify_sealed_data(const uint8_t *sealed_data,
-                               uint32_t sealed_data_size,
-                               const void *curr_data, size_t curr_data_size,
-                               void *secrets, size_t secrets_size)
+static bool verify_sealed_data(const uint8_t *sealed_data,  uint32_t sealed_data_size, const void *curr_data, size_t curr_data_size, void *secrets, size_t secrets_size)
 {
     /* sealed data is hash of state data and optional secret */
     struct __packed {
@@ -476,12 +467,8 @@ bool seal_post_k_state(void)
     /* calculate the memory integrity hash */
     uint32_t key_size = sizeof(secrets.mac_key);
     /* key must be random and secret even though auth not necessary */
-    if ( !g_tpm->get_random(g_tpm, 2, secrets.mac_key, &key_size) ||
-         key_size != sizeof(secrets.mac_key) )
-        return false;
-    if ( !measure_memory_integrity(&g_post_k_s3_state.kernel_integ,
-                                   secrets.mac_key) )
-        return false;
+    if ( !g_tpm->get_random(g_tpm, 2, secrets.mac_key, &key_size) ||         key_size != sizeof(secrets.mac_key) )        return false;
+    if ( !measure_memory_integrity(&g_post_k_s3_state.kernel_integ,                                   secrets.mac_key) )        return false;
 
     /* copy s3_key into secrets to be sealed */
     memcpy(secrets.shared_key, _tboot_shared.s3_key, sizeof(secrets.shared_key));
@@ -489,10 +476,7 @@ bool seal_post_k_state(void)
     print_post_k_s3_state();
 
     sealed_post_k_state_size = sizeof(sealed_post_k_state);
-    if ( !seal_data(&g_post_k_s3_state, sizeof(g_post_k_s3_state),
-                    &secrets, sizeof(secrets),
-                    sealed_post_k_state, &sealed_post_k_state_size) )
-        return false;
+    if ( !seal_data(&g_post_k_s3_state, sizeof(g_post_k_s3_state), &secrets, sizeof(secrets), sealed_post_k_state, &sealed_post_k_state_size) ) return false;
 
     /* wipe secrets from memory */
     memset(&secrets, 0, sizeof(secrets));
diff --git a/tboot/common/pci_cfgreg.c b/tboot/common/pci_cfgreg.c
old mode 100755
new mode 100644
diff --git a/tboot/common/tboot.c b/tboot/common/tboot.c
index 22b9ec0..97c8fb1 100644
--- a/tboot/common/tboot.c
+++ b/tboot/common/tboot.c
@@ -165,8 +165,7 @@ static void post_launch(void)
     /* backup DMAR table */
     save_vtd_dmar_table();
 
-    if ( s3_flag  )
-        s3_launch();
+    if ( s3_flag  )    s3_launch();
 
     /* remove all TXT modules before verifying modules */
     remove_txt_modules(g_ldr_ctx);
@@ -180,14 +179,12 @@ static void post_launch(void)
     apply_policy(err);
 
     /* ensure all modules are in RAM */
-    if ( !verify_modules(g_ldr_ctx) )
-        apply_policy(TB_ERR_POST_LAUNCH_VERIFICATION);
+    if ( !verify_modules(g_ldr_ctx) )     apply_policy(TB_ERR_POST_LAUNCH_VERIFICATION);
 
     /* verify that tboot is in valid RAM (i.e. E820_RAM) */
     base = (uint64_t)TBOOT_BASE_ADDR;
     size = (uint64_t)((unsigned long)&_end - base);
-    printk(TBOOT_INFO"verifying tboot and its page table (%Lx - %Lx) in e820 table\n\t",
-           base, (base + size - 1));
+    printk(TBOOT_INFO"verifying tboot and its page table (%Lx - %Lx) in e820 table\n\t",  base, (base + size - 1));
     if ( e820_check_region(base, size) != E820_RAM ) {
         printk(TBOOT_ERR": failed.\n");
         apply_policy(TB_ERR_FATAL);
@@ -199,19 +196,15 @@ static void post_launch(void)
     base = (uint64_t)TBOOT_BASE_ADDR;
     size = (uint64_t)get_tboot_mem_end() - base;
     uint32_t mem_type = is_kernel_linux() ? E820_RESERVED : E820_UNUSABLE;
-    printk(TBOOT_INFO"protecting tboot (%Lx - %Lx) in e820 table\n", base,
-           (base + size - 1));
-    if ( !e820_protect_region(base, size, mem_type) )
-        apply_policy(TB_ERR_FATAL);
+    printk(TBOOT_INFO"protecting tboot (%Lx - %Lx) in e820 table\n", base,      (base + size - 1));
+    if ( !e820_protect_region(base, size, mem_type) )        apply_policy(TB_ERR_FATAL);
 
     /* if using memory logging, reserve log area */
     if ( g_log_targets & TBOOT_LOG_TARGET_MEMORY ) {
         base = TBOOT_SERIAL_LOG_ADDR;
         size = TBOOT_SERIAL_LOG_SIZE;
-        printk(TBOOT_INFO"reserving tboot memory log (%Lx - %Lx) in e820 table\n", base,
-               (base + size - 1));
-        if ( !e820_protect_region(base, size, E820_RESERVED) )
-            apply_policy(TB_ERR_FATAL);
+        printk(TBOOT_INFO"reserving tboot memory log (%Lx - %Lx) in e820 table\n", base,        (base + size - 1));
+        if ( !e820_protect_region(base, size, E820_RESERVED) )         apply_policy(TB_ERR_FATAL);
     }
 
     /* replace map in loader context with copy */
@@ -228,14 +221,12 @@ static void post_launch(void)
     /*
      * verify nv indices against policy
      */
-    if ( (g_tpm->major == TPM12_VER_MAJOR) &&  get_tboot_measure_nv() )
-        verify_all_nvindices();
+    if ( (g_tpm->major == TPM12_VER_MAJOR) &&  get_tboot_measure_nv() )        verify_all_nvindices();
 
     /*
      * seal hashes of modules and VL policy to current value of PCR17 & 18
      */
-    if ( !seal_pre_k_state() )
-        apply_policy(TB_ERR_S3_INTEGRITY);
+    if ( !seal_pre_k_state() )        apply_policy(TB_ERR_S3_INTEGRITY);
 
     /*
      * init MLE/kernel shared data page
@@ -248,8 +239,7 @@ static void post_launch(void)
     _tboot_shared.tboot_base = (uint32_t)&_start;
     _tboot_shared.tboot_size = (uint32_t)&_end - (uint32_t)&_start;
     uint32_t key_size = sizeof(_tboot_shared.s3_key);
-    if ( !g_tpm->get_random(g_tpm, 2, _tboot_shared.s3_key, &key_size) ||
-         key_size != sizeof(_tboot_shared.s3_key) )
+    if ( !g_tpm->get_random(g_tpm, 2, _tboot_shared.s3_key, &key_size) || key_size != sizeof(_tboot_shared.s3_key) )
         apply_policy(TB_ERR_S3_INTEGRITY);
     _tboot_shared.num_in_wfs = atomic_read(&ap_wfs_count);
     if ( use_mwait() ) {
@@ -331,7 +321,7 @@ void begin_launch(void *addr, uint32_t magic)
 {
     tb_error_t err;
 
-    if (g_ldr_ctx->type == 0)
+    if (g_ldr_ctx->type == 0)        
         determine_loader_type(addr, magic);
 
     /* on pre-SENTER boot, copy command line to buffer in tboot image
@@ -364,17 +354,16 @@ void begin_launch(void *addr, uint32_t magic)
     if ( get_tboot_call_racm_check() )
         check_racm_result(); /* never return */
 
-    if ( s3_flag )
-        printk(TBOOT_INFO"resume from S3\n");
-
+    if (is_launched()) printk(TBOOT_INFO"SINIT ACM successfully returned...\n");
+    if ( s3_flag ) printk(TBOOT_INFO"Resume from S3...\n");
+    
     /* RLM scaffolding
        if (g_ldr_ctx->type == 2)
        print_loader_ctx(g_ldr_ctx);
     */
 
     /* clear resume vector on S3 resume so any resets will not use it */
-    if ( !is_launched() && s3_flag )
-        set_s3_resume_vector(&_tboot_shared.acpi_sinfo, 0);
+    if ( !is_launched() && s3_flag )        set_s3_resume_vector(&_tboot_shared.acpi_sinfo, 0);
 
     /* we should only be executing on the BSP */
     if ( !(rdmsr(MSR_APICBASE) & APICBASE_BSP) ) {
@@ -385,8 +374,7 @@ void begin_launch(void *addr, uint32_t magic)
 
     /* make copy of e820 map that we will use and adjust */
     if ( !s3_flag ) {
-        if ( !copy_e820_map(g_ldr_ctx) )
-            apply_policy(TB_ERR_FATAL);
+        if ( !copy_e820_map(g_ldr_ctx) )  apply_policy(TB_ERR_FATAL);
     }
 
     /* we need to make sure this is a (TXT-) capable platform before using */
@@ -394,10 +382,17 @@ void begin_launch(void *addr, uint32_t magic)
     /* has already been launched */
 
     /* make TPM ready for measured launch */
-    if ( !tpm_detect() )
-        apply_policy(TB_ERR_TPM_NOT_READY);
 
-    /* read tboot policy from TPM-NV (will use default if none in TPM-NV) */
+    /*
+    if (!is_launched()) {
+		if ( !tpm_detect() )        
+			apply_policy(TB_ERR_TPM_NOT_READY);
+    }
+    */
+
+   if ( !tpm_detect() ) 	apply_policy(TB_ERR_TPM_NOT_READY);
+
+    /* read tboot verified launch control policy from TPM-NV (will use default if none in TPM-NV) */
     err = set_policy();
     apply_policy(err);
 
@@ -422,8 +417,10 @@ void begin_launch(void *addr, uint32_t magic)
         apply_policy(TB_ERR_FATAL);
 
     /* this is being called post-measured launch */
-    if ( is_launched() )
-        post_launch();
+    if ( is_launched() ){
+        printk(TBOOT_INFO"Post_launch started ...\n");
+	 post_launch();
+    }
 
     /* make the CPU ready for measured launch */
     if ( !prepare_cpu() )
@@ -496,8 +493,7 @@ static void shutdown_system(uint32_t shutdown_type)
         case TB_SHUTDOWN_S3:
             copy_s3_wakeup_entry();
             /* write our S3 resume vector to ACPI resume addr */
-            set_s3_resume_vector(&_tboot_shared.acpi_sinfo,
-                                 TBOOT_S3_WAKEUP_ADDR);
+            set_s3_resume_vector(&_tboot_shared.acpi_sinfo,  TBOOT_S3_WAKEUP_ADDR);
             /* fall through for rest of Sx handling */
         case TB_SHUTDOWN_S4:
         case TB_SHUTDOWN_S5:
@@ -558,12 +554,10 @@ void shutdown(void)
         restore_vtd_dmar_table();
 
         /* save kernel/VMM resume vector for sealing */
-        g_post_k_s3_state.kernel_s3_resume_vector =
-            _tboot_shared.acpi_sinfo.kernel_s3_resume_vector;
+        g_post_k_s3_state.kernel_s3_resume_vector =  _tboot_shared.acpi_sinfo.kernel_s3_resume_vector;
 
         /* create and seal memory integrity measurement */
-        if ( !seal_post_k_state() )
-            apply_policy(TB_ERR_S3_INTEGRITY);
+        if ( !seal_post_k_state() )   apply_policy(TB_ERR_S3_INTEGRITY);
             /* OK to leave key in memory on failure since if user cared they
                would have policy that doesn't continue for TB_ERR_S3_INTEGRITY
                error */
@@ -592,8 +586,7 @@ void shutdown(void)
         if ( !use_mwait() ) {
             /* force APs to exit mini-guests if any are in and wait until */
             /* all are out before shutting down TXT */
-            printk(TBOOT_INFO"waiting for APs (%u) to exit guests...\n",
-                   atomic_read(&ap_wfs_count));
+            printk(TBOOT_INFO"waiting for APs (%u) to exit guests...\n", atomic_read(&ap_wfs_count));
             force_aps_exit();
             uint32_t timeout = AP_GUEST_EXIT_TIMEOUT;
             do {
diff --git a/tboot/common/tpm.c b/tboot/common/tpm.c
index 1a1463e..9e00a29 100644
--- a/tboot/common/tpm.c
+++ b/tboot/common/tpm.c
@@ -46,78 +46,18 @@
 #include <sha1.h>
 
 __data struct tpm_if *g_tpm = NULL;
-u16 tboot_alg_list[] = {TB_HALG_SHA1,
-                        TB_HALG_SHA256};
+u16 tboot_alg_list[] = {TB_HALG_SHA1, TB_HALG_SHA256};
+
+
 
-/*
- * TPM registers and data structures
- *
- * register values are offsets from each locality base
- * see {read,write}_tpm_reg() for data struct format
- */
 
-/* TPM_ACCESS_x */
-#define TPM_REG_ACCESS           0x00
-typedef union {
-    u8 _raw[1];                      /* 1-byte reg */
-    struct __packed {
-        u8 tpm_establishment   : 1;  /* RO, 0=T/OS has been established
-                                        before */
-        u8 request_use         : 1;  /* RW, 1=locality is requesting TPM use */
-        u8 pending_request     : 1;  /* RO, 1=other locality is requesting
-                                        TPM usage */
-        u8 seize               : 1;  /* WO, 1=seize locality */
-        u8 been_seized         : 1;  /* RW, 1=locality seized while active */
-        u8 active_locality     : 1;  /* RW, 1=locality is active */
-        u8 reserved            : 1;
-        u8 tpm_reg_valid_sts   : 1;  /* RO, 1=other bits are valid */
-    };
-} tpm_reg_access_t;
-
-/* TPM_STS_x */
-#define TPM_REG_STS              0x18
-typedef union {
-    u8 _raw[3];                  /* 3-byte reg */
-    struct __packed {
-        u8 reserved1       : 1;
-        u8 response_retry  : 1;  /* WO, 1=re-send response */
-        u8 self_test_done  : 1;  /* RO, only for version 2 */
-        u8 expect          : 1;  /* RO, 1=more data for command expected */
-        u8 data_avail      : 1;  /* RO, 0=no more data for response */
-        u8 tpm_go          : 1;  /* WO, 1=execute sent command */
-        u8 command_ready   : 1;  /* RW, 1=TPM ready to receive new cmd */
-        u8 sts_valid       : 1;  /* RO, 1=data_avail and expect bits are
-                                    valid */
-        u16 burst_count    : 16; /* RO, # read/writes bytes before wait */
-    };
-} tpm12_reg_sts_t;
 
-typedef union {
-    u8 _raw[4];                  /* 4-byte reg */
-    struct __packed {
-        u8 reserved1       : 1;
-        u8 response_retry  : 1;  /* WO, 1=re-send response */
-        u8 self_test_done  : 1;  /* RO, only for version 2 */
-        u8 expect          : 1;  /* RO, 1=more data for command expected */
-        u8 data_avail      : 1;  /* RO, 0=no more data for response */
-        u8 tpm_go          : 1;  /* WO, 1=execute sent command */
-        u8 command_ready   : 1;  /* RW, 1=TPM ready to receive new cmd */
-        u8 sts_valid       : 1;  /* RO, 1=data_avail and expect bits are
-                                    valid */
-        u16 burst_count    : 16; /* RO, # read/writes bytes before wait */
-        /* version >= 2 */
-        u8 command_cancel       : 1;
-        u8 reset_establishment  : 1;
-        u8 tpm_family           : 2;
-        u8 reserved2            : 4;
-    };
-} tpm20_reg_sts_t;
 
 /* Global variables for TPM status register */
 static tpm20_reg_sts_t       g_reg_sts, *g_reg_sts_20 = &g_reg_sts;
 static tpm12_reg_sts_t       *g_reg_sts_12 = (tpm12_reg_sts_t *)&g_reg_sts;
 
-static u8 g_tpm_family = 0;
+uint8_t g_tpm_family = 0;
 
 /* TPM_DATA_FIFO_x */
 #define TPM_REG_DATA_FIFO        0x24
@@ -125,6 +65,10 @@ typedef union {
         uint8_t _raw[1];                      /* 1-byte reg */
 } tpm_reg_data_fifo_t;
 
+typedef union {
+        uint8_t _raw[1];
+} tpm_reg_data_crb_t;
+
 #define TPM_ACTIVE_LOCALITY_TIME_OUT    \
           (TIMEOUT_UNIT * g_tpm->timeout.timeout_a)  /* according to spec */
 #define TPM_CMD_READY_TIME_OUT          \
@@ -159,6 +103,98 @@ static void tpm_send_cmd_ready_status(uint32_t locality)
     write_tpm_sts_reg(locality);
 }
 
+
+static bool tpm_send_cmd_ready_status_crb(uint32_t locality)
+{
+      tpm_reg_ctrl_request_t reg_ctrl_request;
+      tpm_reg_ctrl_sts_t reg_ctrl_sts;
+
+      read_tpm_reg(locality, TPM_CRB_CTRL_STS, &reg_ctrl_sts);
+
+#ifdef TPM_TRACE
+      printk(TBOOT_INFO"1. reg_ctrl_sts.tpmidle: 0x%x\n", reg_ctrl_sts.tpmidle); 	
+      printk(TBOOT_INFO"1. reg_ctrl_sts.tpmsts: 0x%x\n", reg_ctrl_sts.tpmsts); 	
+#endif
+
+	if ( reg_ctrl_sts.tpmidle== 1) {
+           reg_ctrl_request._raw[0] = 0;
+           reg_ctrl_request.cmdReady = 1;
+	    write_tpm_reg(locality, TPM_CRB_CTRL_REQ, &reg_ctrl_request);
+
+	    return true;
+	}
+
+      reg_ctrl_request._raw[0] = 0;
+      reg_ctrl_request.goIdle = 1;
+      write_tpm_reg(locality, TPM_CRB_CTRL_REQ, &reg_ctrl_request);
+	  
+      uint32_t i = 0;
+      do {
+          read_tpm_reg(locality, TPM_CRB_CTRL_REQ, &reg_ctrl_request);
+          if ( reg_ctrl_request.goIdle == 0) 
+		break;
+          else {
+              cpu_relax(); 
+	       read_tpm_reg(locality, TPM_CRB_CTRL_REQ, &reg_ctrl_request);
+
+#ifdef TPM_TRACE
+		printk(TBOOT_INFO"1. reg_ctrl_request.goIdle: 0x%x\n", reg_ctrl_request.goIdle);
+		printk(TBOOT_INFO"1. reg_ctrl_request.cmdReady: 0x%x\n", reg_ctrl_request.cmdReady);
+#endif
+
+          }
+          i++;
+       } while ( i <= TPM_DATA_AVAIL_TIME_OUT);
+
+       if ( i > TPM_DATA_AVAIL_TIME_OUT ) {
+            printk(TBOOT_ERR"TPM: reg_ctrl_request.goidle timeout!\n");
+            return false;
+       }
+
+	read_tpm_reg(locality, TPM_CRB_CTRL_STS, &reg_ctrl_sts);
+
+#ifdef TPM_TRACE
+	printk(TBOOT_INFO"2. reg_ctrl_sts.tpmidle: 0x%x\n", reg_ctrl_sts.tpmidle); 	
+       printk(TBOOT_INFO"2. reg_ctrl_sts.tpmsts: 0x%x\n", reg_ctrl_sts.tpmsts); 	
+#endif
+
+       reg_ctrl_request._raw[0] = 0;
+       reg_ctrl_request.cmdReady = 1;
+	write_tpm_reg(locality, TPM_CRB_CTRL_REQ, &reg_ctrl_request);
+
+#ifdef TPM_TRACE	
+	printk(TBOOT_INFO"2. reg_ctrl_request.goIdle: 0x%x\n", reg_ctrl_request.goIdle);
+	printk(TBOOT_INFO"2. reg_ctrl_request.cmdReady: 0x%x\n", reg_ctrl_request.cmdReady);
+#endif
+ 
+	read_tpm_reg(locality, TPM_CRB_CTRL_STS, &reg_ctrl_sts);
+
+#ifdef TPM_TRACE
+	printk(TBOOT_INFO"2. reg_ctrl_sts.tpmidle: 0x%x\n", reg_ctrl_sts.tpmidle); 	
+       printk(TBOOT_INFO"2. reg_ctrl_sts.tpmsts: 0x%x\n", reg_ctrl_sts.tpmsts); 	
+#endif
+
+	return true;
+	
+}
+
+static bool tpm_check_cmd_ready_status_crb(uint32_t locality)
+{
+    tpm_reg_ctrl_request_t reg_ctrl_request; 
+    read_tpm_reg(locality, TPM_CRB_CTRL_REQ, &reg_ctrl_request);
+
+#ifdef TPM_TRACE
+    printk(TBOOT_INFO"3. reg_ctrl_request.goIdle: 0x%x\n", reg_ctrl_request.goIdle);
+    printk(TBOOT_INFO"3. reg_ctrl_request.cmdReady: 0x%x\n", reg_ctrl_request.cmdReady);
+#endif
+
+    if ( reg_ctrl_request.cmdReady == 0) 
+		return true;
+    else
+		return false;
+
+}
+
 static bool tpm_check_cmd_ready_status(uint32_t locality)
 {
     read_tpm_sts_reg(locality);
@@ -222,7 +258,7 @@ bool tpm_validate_locality(uint32_t locality)
 {
     uint32_t i;
     tpm_reg_access_t reg_acc;
-
+    
     for ( i = TPM_VALIDATE_LOCALITY_TIME_OUT; i > 0; i-- ) {
         /*
          * TCG spec defines reg_acc.tpm_reg_valid_sts bit to indicate whether
@@ -235,13 +271,35 @@ bool tpm_validate_locality(uint32_t locality)
             return true;
         cpu_relax();
     }
-
     if ( i <= 0 )
         printk(TBOOT_ERR"TPM: tpm_validate_locality timeout\n");
 
     return false;
 }
 
+bool tpm_validate_locality_crb(uint32_t locality)
+{
+    uint32_t i;
+    tpm_reg_loc_state_t reg_loc_state;
+
+    for ( i = TPM_VALIDATE_LOCALITY_TIME_OUT; i > 0; i-- ) {
+        /*
+         *  Platfrom Tpm  Profile for TPM 2.0 SPEC
+         */
+        read_tpm_reg(locality, TPM_REG_LOC_STATE, &reg_loc_state);
+ 	 if ( reg_loc_state.tpm_reg_valid_sts == 1 && reg_loc_state.loc_assigned == 1 && reg_loc_state.active_locality == locality) {
+			 printk(TBOOT_INFO"TPM: reg_loc_state._raw[0]:  0x%x\n", reg_loc_state._raw[0]);
+			 return true;
+        	}
+        cpu_relax(); 
+    }
+
+    printk(TBOOT_ERR"TPM: tpm_validate_locality_crb timeout\n");
+    printk(TBOOT_INFO"TPM: reg_loc_state._raw[0]: 0x%x\n", reg_loc_state._raw[0]);
+    return false;
+}
+
+
 static bool tpm_wait_cmd_ready(uint32_t locality)
 {
     uint32_t            i;
@@ -276,13 +334,13 @@ static bool tpm_wait_cmd_ready(uint32_t locality)
     } while ( i <= TPM_ACTIVE_LOCALITY_TIME_OUT);
 
     if ( i > TPM_ACTIVE_LOCALITY_TIME_OUT ) {
-        printk(TBOOT_ERR"TPM: access reg request use timeout\n");
+        printk(TBOOT_ERR"TPM: FIFO_INF access reg request use timeout\n");
         return false;
     }
 
     /* ensure the TPM is ready to accept a command */
 #ifdef TPM_TRACE
-    printk(TBOOT_INFO"TPM: wait for cmd ready ");
+    printk(TBOOT_INFO"TPM: wait for cmd ready \n");
 #endif
     i = 0;
     do {
@@ -317,8 +375,43 @@ RelinquishControl:
     return false;
 }
 
-bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,
-                    u8 *out, u32 *out_size)
+static bool tpm_wait_cmd_ready_crb(uint32_t locality)
+{
+    uint32_t i;
+
+    /* ensure the TPM is ready to accept a command */
+#ifdef TPM_TRACE
+    printk(TBOOT_INFO"TPM: wait for cmd ready \n");
+#endif
+    tpm_send_cmd_ready_status_crb(locality);
+    i = 0;
+    do {
+        if ( tpm_check_cmd_ready_status_crb(locality) )
+            break;
+        else
+            cpu_relax();
+        i++;
+    } while ( i <= TPM_CMD_READY_TIME_OUT );
+
+    if ( i > TPM_CMD_READY_TIME_OUT ) {
+        //tpm_print_status_register();
+        printk(TBOOT_INFO"TPM: tpm timeout for command_ready\n");
+        goto RelinquishControl;
+    }
+
+    return true;
+
+RelinquishControl:
+    /* deactivate current locality */
+	  //tpm_reg_loc_ctrl_t    reg_loc_ctrl;
+        //reg_loc_ctrl._raw[0] = 0;
+    //reg_loc_ctrl.relinquish = 1;
+    //write_tpm_reg(locality, TPM_REG_LOC_CTRL, &reg_loc_ctrl);
+
+    return false;
+}
+
+bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,  u8 *out, u32 *out_size)
 {
     u32 i, rsp_size, offset;
     u16 row_size;
@@ -343,12 +436,11 @@ bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,
         return false;
     }
 
-    if ( !tpm_wait_cmd_ready(locality) )
-        return false;
+    if ( !tpm_wait_cmd_ready(locality) )   return false;
 
 #ifdef TPM_TRACE
     {
-        printk(TBOOT_DETA"TPM: cmd size = %d\nTPM: cmd content: ", in_size);
+        printk(TBOOT_DETA"TPM: cmd size = 0x%x\nTPM: cmd content: ", in_size);
         print_hex("TPM: \t", in, in_size);
     }
 #endif
@@ -360,10 +452,8 @@ bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,
         do {
             /* find out how many bytes the TPM can accept in a row */
             row_size = tpm_get_burst_count(locality);
-            if ( row_size > 0 )
-                break;
-            else
-                cpu_relax();
+            if ( row_size > 0 )   break;
+            else  cpu_relax();
             i++;
         } while ( i <= TPM_CMD_WRITE_TIME_OUT );
         if ( i > TPM_CMD_WRITE_TIME_OUT ) {
@@ -372,17 +462,13 @@ bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,
             goto RelinquishControl;
         }
 
-        for ( ; row_size > 0 && offset < in_size; row_size--, offset++ )
-            write_tpm_reg(locality, TPM_REG_DATA_FIFO,
-                          (tpm_reg_data_fifo_t *)&in[offset]);
+        for ( ; row_size > 0 && offset < in_size; row_size--, offset++ )  write_tpm_reg(locality, TPM_REG_DATA_FIFO,  (tpm_reg_data_fifo_t *)&in[offset]);
     } while ( offset < in_size );
 
     i = 0;
     do {
-        if ( tpm_check_expect_status(locality) )
-            break;
-        else
-            cpu_relax();
+        if ( tpm_check_expect_status(locality) )  break;
+        else   cpu_relax();
         i++;
     } while ( i <= TPM_DATA_AVAIL_TIME_OUT );
     if ( i > TPM_DATA_AVAIL_TIME_OUT ) {
@@ -397,10 +483,8 @@ bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,
     /* check for data available */
     i = 0;
     do {
-        if ( tpm_check_da_status(locality) )
-            break;
-        else
-            cpu_relax();
+        if ( tpm_check_da_status(locality) )  break;
+        else  cpu_relax();
         i++;
     } while ( i <= TPM_DATA_AVAIL_TIME_OUT );
     if ( i > TPM_DATA_AVAIL_TIME_OUT ) {
@@ -416,10 +500,8 @@ bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,
         i = 0;
         do {
             row_size = tpm_get_burst_count(locality);
-            if ( row_size > 0 )
-                break;
-            else
-                cpu_relax();
+            if ( row_size > 0 )  break;
+            else cpu_relax();
             i++;
         } while ( i <= TPM_RSP_READ_TIME_OUT );
         if ( i > TPM_RSP_READ_TIME_OUT ) {
@@ -429,24 +511,19 @@ bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,
         }
 
         for ( ; row_size > 0 && offset < *out_size; row_size--, offset++ ) {
-            if ( offset < *out_size )
-                read_tpm_reg(locality, TPM_REG_DATA_FIFO,
-                             (tpm_reg_data_fifo_t *)&out[offset]);
+            if ( offset < *out_size )  read_tpm_reg(locality, TPM_REG_DATA_FIFO, (tpm_reg_data_fifo_t *)&out[offset]);
             else {
                 /* discard the responded bytes exceeding out buf size */
                 tpm_reg_data_fifo_t discard;
-                read_tpm_reg(locality, TPM_REG_DATA_FIFO,
-                             (tpm_reg_data_fifo_t *)&discard);
+                read_tpm_reg(locality, TPM_REG_DATA_FIFO,  (tpm_reg_data_fifo_t *)&discard);
             }
 
             /* get outgoing data size */
             if ( offset == RSP_RST_OFFSET - 1 ) {
-                reverse_copy(&rsp_size, &out[RSP_SIZE_OFFSET],
-                             sizeof(rsp_size));
+                reverse_copy(&rsp_size, &out[RSP_SIZE_OFFSET], sizeof(rsp_size));
             }
         }
-    } while ( offset < RSP_RST_OFFSET ||
-              (offset < rsp_size && offset < *out_size) );
+    } while ( offset < RSP_RST_OFFSET || (offset < rsp_size && offset < *out_size) );
 
     *out_size = (*out_size > rsp_size) ? rsp_size : *out_size;
 
@@ -469,6 +546,137 @@ RelinquishControl:
     return ret;
 }
 
+
+bool tpm_submit_cmd_crb(u32 locality, u8 *in, u32 in_size,  u8 *out, u32 *out_size)
+{
+    uint32_t i;
+    
+    bool ret = true;
+
+    //tpm_reg_loc_ctrl_t reg_loc_ctrl;
+    tpm_reg_ctrl_start_t start;
+
+    tpm_reg_ctrl_cmdsize_t  CmdSize;
+    tpm_reg_ctrl_cmdaddr_t  CmdAddr;
+    tpm_reg_ctrl_rspsize_t  RspSize;
+    tpm_reg_ctrl_rspaddr_t  RspAddr;
+    uint32_t  tpm_crb_data_buffer_base;
+	
+    if ( locality >= TPM_NR_LOCALITIES ) {
+        printk(TBOOT_WARN"TPM: Invalid locality for tpm_submit_cmd_crb()\n");
+        return false;
+    }
+    if ( in == NULL || out == NULL || out_size == NULL ) {
+        printk(TBOOT_WARN"TPM: Invalid parameter for tpm_submit_cmd_crb()\n");
+        return false;
+    }
+    if ( in_size < CMD_HEAD_SIZE || *out_size < RSP_HEAD_SIZE ) {
+        printk(TBOOT_WARN"TPM: in/out buf size must be larger than 10 bytes\n");
+        return false;
+    }
+
+    if ( !tpm_validate_locality_crb(locality) ) {
+        printk(TBOOT_WARN"TPM: CRB Interface Locality %d is not open\n", locality);
+        return false;
+    }
+
+    if ( !tpm_wait_cmd_ready_crb(locality) ) {
+        printk(TBOOT_WARN"TPM: tpm_wait_cmd_read_crb failed\n");
+	 return false;
+    }
+
+#ifdef TPM_TRACE
+    {
+        printk(TBOOT_DETA"TPM: Before submit, cmd size = 0x%x\nTPM: Before submit, cmd content: ", in_size);
+        print_hex("TPM: \t", in, in_size);
+    }
+#endif
+
+    /* write the command to the TPM CRB  buffer 01-04-2016  */
+//copy *in and size to crb buffer
+
+
+
+    CmdAddr.cmdladdr = TPM_LOCALITY_CRB_BASE_N(locality) | TPM_CRB_DATA_BUFFER;
+    CmdAddr.cmdhaddr = 0;
+    RspAddr.rspaddr = TPM_LOCALITY_CRB_BASE_N(locality) | TPM_CRB_DATA_BUFFER;
+    CmdSize.cmdsize = TPMCRBBUF_LEN;
+    RspSize.rspsize = TPMCRBBUF_LEN;
+    tpm_crb_data_buffer_base = TPM_CRB_DATA_BUFFER;
+	
+
+ #ifdef TPM_TRACE  
+       printk(TBOOT_INFO"CmdAddr.cmdladdr is 0x%x\n",CmdAddr.cmdladdr);
+       printk(TBOOT_INFO"CmdAddr.cmdhaddr is 0x%x\n",CmdAddr.cmdhaddr);
+
+	printk(TBOOT_INFO"CmdSize.cmdsize is 0x%x\n",CmdSize.cmdsize);
+	printk(TBOOT_INFO"RspAddr.rspaddr is 0x%Lx\n",RspAddr.rspaddr);
+	printk(TBOOT_INFO"RspSize.rspsize is 0x%x\n",RspSize.rspsize);
+	
+#endif
+    
+    write_tpm_reg(locality, TPM_CRB_CTRL_CMD_ADDR, &CmdAddr);
+    write_tpm_reg(locality, TPM_CRB_CTRL_CMD_SIZE, &CmdSize);
+    write_tpm_reg(locality, TPM_CRB_CTRL_RSP_ADDR, &RspAddr);
+    write_tpm_reg(locality, TPM_CRB_CTRL_RSP_SIZE, &RspSize);
+    // write the command to the buffer
+    for ( i = 0 ; i< in_size; i++ )  {
+        write_tpm_reg(locality, tpm_crb_data_buffer_base++,  (tpm_reg_data_crb_t *)&in[i]);
+        //tpm_crb_data_buffer_base++;
+    }
+
+    /* command has been written to the TPM, it is time to execute it. */
+    start.start = 1;
+    write_tpm_reg(locality, TPM_CRB_CTRL_START, &start);
+    //read_tpm_reg(locality, TPM_CRB_CTRL_START, &start);
+    printk(TBOOT_INFO"tpm_ctrl_start.start is 0x%x\n",start.start);
+	
+    /* check for data available */
+    i = 0;
+    do {
+	   read_tpm_reg(locality, TPM_CRB_CTRL_START, &start);
+        //printk(TBOOT_INFO"tpm_ctrl_start.start is 0x%x\n",start.start);
+          if ( start.start == 0 ) break;
+          else  cpu_relax();
+          i++;
+    } while ( i <= TPM_DATA_AVAIL_TIME_OUT );
+
+    if ( i > TPM_DATA_AVAIL_TIME_OUT ) {
+        printk(TBOOT_ERR"TPM: wait for data available timeout\n");
+        ret = false;
+        goto RelinquishControl;
+    }
+
+    tpm_crb_data_buffer_base = TPM_CRB_DATA_BUFFER;
+
+    for ( i = 0 ; i< *out_size; i++ )  {
+        read_tpm_reg(locality, tpm_crb_data_buffer_base++, (tpm_reg_data_crb_t *)&out[i]);
+        //tpm_crb_data_buffer_base++;
+    }
+
+  
+
+#ifdef TPM_TRACE
+    {
+        printk(TBOOT_INFO"TPM: After cmd submit, response size = 0x%x\n", *out_size);
+        printk(TBOOT_DETA"TPM: After cmd submit, response content: ");
+        print_hex("TPM: \t", out, *out_size);
+    }
+#endif
+
+    //tpm_send_cmd_ready_status_crb(locality);
+
+RelinquishControl:
+    /* deactivate current locality */
+   // reg_loc_ctrl._raw[0] = 0;
+    //reg_loc_ctrl.relinquish = 1;
+    //write_tpm_reg(locality, TPM_REG_LOC_CTRL, &reg_loc_ctrl);
+
+    return ret;
+
+}
+
+
 bool release_locality(uint32_t locality)
 {
     uint32_t i;
@@ -476,13 +684,11 @@ bool release_locality(uint32_t locality)
     printk(TBOOT_DETA"TPM: releasing locality %u\n", locality);
 #endif
 
-    if ( !tpm_validate_locality(locality) )
-        return true;
+    if ( !tpm_validate_locality(locality) )   return true;
 
     tpm_reg_access_t reg_acc;
     read_tpm_reg(locality, TPM_REG_ACCESS, &reg_acc);
-    if ( reg_acc.active_locality == 0 )
-        return true;
+    if ( reg_acc.active_locality == 0 )    return true;
 
     /* make inactive by writing a 1 */
     reg_acc._raw[0] = 0;
@@ -503,34 +709,142 @@ bool release_locality(uint32_t locality)
     return false;
 }
 
+bool tpm_relinquish_locality_crb(uint32_t locality)
+{
+    uint32_t i;
+    tpm_reg_loc_state_t reg_loc_state;
+    tpm_reg_loc_ctrl_t reg_loc_ctrl;
+	
+#ifdef TPM_TRACE
+    printk(TBOOT_DETA"TPM: releasing CRB_INF locality %u\n", locality);
+#endif
+
+    if ( !tpm_validate_locality_crb(locality) )   return true;
+    read_tpm_reg(locality, TPM_REG_LOC_STATE, &reg_loc_state);
+    if ( reg_loc_state.loc_assigned == 0 )    return true;
+
+    /* make inactive by writing a 1 */
+    reg_loc_ctrl._raw[0] = 0;
+    reg_loc_ctrl.relinquish = 1;
+    write_tpm_reg(locality, TPM_REG_LOC_CTRL, &reg_loc_ctrl);
+
+    i = 0;
+    do {
+        read_tpm_reg(locality, TPM_REG_LOC_STATE, &reg_loc_state);
+        if ( reg_loc_state.loc_assigned == 0 )    return true;
+        else cpu_relax();
+        i++;
+    } while ( i <= TPM_ACTIVE_LOCALITY_TIME_OUT );
+
+    printk(TBOOT_INFO"TPM: CRB_INF release locality timeout\n");
+    return false;
+}
+
+
+
+bool is_tpm_crb(void)
+{      
+     tpm_crb_interface_id_t crb_interface;
+     read_tpm_reg(0, TPM_INTERFACE_ID, &crb_interface);
+     if (crb_interface.interface_type == TPM_INTERFACE_ID_CRB  ) {
+	 printk(TBOOT_INFO"TPM: PTP CRB interface is active...\n");
+	 if (g_tpm_family != TPM_IF_20_CRB ) g_tpm_family = TPM_IF_20_CRB;
+        return true;
+     }
+     if (crb_interface.interface_type == TPM_INTERFACE_ID_FIFO_20) {
+	  printk(TBOOT_INFO"TPM: TPM 2.0 FIFO interface is active...\n");     
+	  if (g_tpm_family != TPM_IF_20_FIFO) g_tpm_family = TPM_IF_20_FIFO;
+     }
+     return false;	
+}
+
+
 bool prepare_tpm(void)
 {
     /*
      * must ensure TPM_ACCESS_0.activeLocality bit is clear
      * (: locality is not active)
      */
+   if (is_tpm_crb()) 
+//   	return release_locality_crb(0);
+       return true;
+   else 
+   	return release_locality(0);
+}
+
+bool tpm_request_locality_crb(uint32_t locality){
+
+    uint32_t            i;
+    tpm_reg_loc_state_t  reg_loc_state;
+    tpm_reg_loc_ctrl_t    reg_loc_ctrl;
+    /* request access to the TPM from locality N */
+    reg_loc_ctrl._raw[0] = 0;
+    reg_loc_ctrl.requestAccess = 1;
+    write_tpm_reg(locality, TPM_REG_LOC_CTRL, &reg_loc_ctrl);
+
+    i = 0;
+    do {
+        read_tpm_reg(locality, TPM_REG_LOC_STATE, &reg_loc_state);
+        if ( reg_loc_state.active_locality == locality && reg_loc_state.loc_assigned == 1)
+            break;
+        else
+            cpu_relax();
+        i++;
+    } while ( i <= TPM_ACTIVE_LOCALITY_TIME_OUT);
+
+    if ( i > TPM_ACTIVE_LOCALITY_TIME_OUT ) {
+        printk(TBOOT_ERR"TPM: access loc request use timeout\n");
+        return false;
+    }
+
+    return true;
 
-    return release_locality(0);
 }
 
+
 bool tpm_detect(void)
 {
-    g_tpm = &tpm_12_if; /* Don't leave g_tpm as NULL*/
-    if ( !tpm_validate_locality(0) ) {
-        printk(TBOOT_ERR"TPM: Locality 0 is not open\n");
-        return false;
+    if (is_tpm_crb()) {
+         printk(TBOOT_INFO"TPM: This is Intel PTT, TPM Family 0x%d\n", g_tpm_family);
+	  if ( tpm_validate_locality_crb(0) ) printk(TBOOT_INFO"TPM: CRB_INF Locality 0 is open\n");
+         else {
+                     if (!txt_is_launched()) {
+			    printk(TBOOT_INFO"TPM: CRB_INF request access to Locality 0...\n");
+			    if (!tpm_request_locality_crb(0)) {
+			        printk(TBOOT_ERR"TPM: CRB_INF Locality 0 request failed...\n");
+				 return false;
+			    }
+                     }
+			else {
+			     printk(TBOOT_INFO"TPM: CRB_INF request access to Locality 2...\n");
+			     if (!tpm_request_locality_crb(2)) {
+		 	          printk(TBOOT_ERR"TPM: CRB_INF Locality 2 request failed...\n");
+                               return false;
+			     }
+			}
+         	}
     }
-
-    /* determine TPM family from command check */
-    if ( g_tpm->check() )
-        g_tpm_family = 0;
-    else
-        g_tpm_family = 1;
-    printk(TBOOT_INFO"TPM: TPM Family 0x%d\n", g_tpm_family);
-    if (g_tpm_family == 1)
-        g_tpm = &tpm_20_if;
-    else
-        g_tpm = &tpm_12_if;
+    else {
+		g_tpm = &tpm_12_if; /* Don't leave g_tpm as NULL*/
+		if ( tpm_validate_locality(0) )  printk(TBOOT_INFO"TPM: FIFO_INF Locality 0 is open\n");
+		else {	
+			printk(TBOOT_ERR"TPM: FIFO_INF Locality 0 is not open\n");
+			return false;
+			}
+		/* determine TPM family from command check */
+		if ( g_tpm->check() )  {
+			g_tpm_family = TPM_IF_12;
+			printk(TBOOT_INFO"TPM: discrete TPM1.2 Family 0x%d\n", g_tpm_family);	
+			}
+		else {
+			g_tpm_family = TPM_IF_20_FIFO;
+			printk(TBOOT_INFO"TPM: discrete TPM2.0 Family 0x%d\n", g_tpm_family);
+			}
+	}
+   
+    if (g_tpm_family == TPM_IF_12)  g_tpm = &tpm_12_if;
+    if (g_tpm_family == TPM_IF_20_FIFO)  g_tpm = &tpm_20_if;
+    if (g_tpm_family == TPM_IF_20_CRB)  g_tpm = &tpm_20_if;
 
     g_tpm->cur_loc = 0;
     g_tpm->timeout.timeout_a = TIMEOUT_A;
@@ -547,11 +861,9 @@ void tpm_print(struct tpm_if *ti)
         return;
 
     printk(TBOOT_INFO"TPM attribute:\n");
-    printk(TBOOT_INFO"\t extend policy %d\n", ti->extpol);
-    printk(TBOOT_INFO"\t current alg id 0x%x\n", ti->cur_alg);
-    printk(TBOOT_INFO"\t timeout values: A: %u, B: %u, C: %u, D: %u\n",
-            ti->timeout.timeout_a, ti->timeout.timeout_b, ti->timeout.timeout_c,
-            ti->timeout.timeout_d);
+    printk(TBOOT_INFO"\t extend policy: %d\n", ti->extpol);
+    printk(TBOOT_INFO"\t current alg id: 0x%x\n", ti->cur_alg);
+    printk(TBOOT_INFO"\t timeout values: A: %u, B: %u, C: %u, D: %u\n", ti->timeout.timeout_a, ti->timeout.timeout_b, ti->timeout.timeout_c, ti->timeout.timeout_d);
 }
 
 /*
diff --git a/tboot/common/tpm_12.c b/tboot/common/tpm_12.c
index 126203a..af2d62f 100644
--- a/tboot/common/tpm_12.c
+++ b/tboot/common/tpm_12.c
@@ -144,8 +144,7 @@ static uint8_t     rsp_buf[TPM_RSP_SIZE_MAX];
 #define WRAPPER_IN_MAX_SIZE     (TPM_CMD_SIZE_MAX - CMD_HEAD_SIZE)
 #define WRAPPER_OUT_MAX_SIZE    (TPM_RSP_SIZE_MAX - RSP_HEAD_SIZE)
 
-static uint32_t _tpm12_submit_cmd(uint32_t locality, uint16_t tag, uint32_t cmd,
-                                  uint32_t arg_size, uint32_t *out_size)
+static uint32_t _tpm12_submit_cmd(uint32_t locality, uint16_t tag, uint32_t cmd,  uint32_t arg_size, uint32_t *out_size)
 {
     uint32_t    ret;
     uint32_t    cmd_size, rsp_size = 0;
@@ -175,8 +174,7 @@ static uint32_t _tpm12_submit_cmd(uint32_t locality, uint16_t tag, uint32_t cmd,
 
     rsp_size = RSP_HEAD_SIZE + *out_size;
     rsp_size = (rsp_size > TPM_RSP_SIZE_MAX) ? TPM_RSP_SIZE_MAX: rsp_size;
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_FAIL;
+    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) ) return TPM_FAIL;
 
     /*
      * should subtract 10 bytes from real response size:
@@ -187,22 +185,18 @@ static uint32_t _tpm12_submit_cmd(uint32_t locality, uint16_t tag, uint32_t cmd,
     rsp_size -= (rsp_size > RSP_HEAD_SIZE) ? RSP_HEAD_SIZE : rsp_size;
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(uint32_t));
-    if ( ret != TPM_SUCCESS )
-        return ret;
+    if ( ret != TPM_SUCCESS )     return ret;
 
-    if ( *out_size == 0 || rsp_size == 0 )
-        *out_size = 0;
+    if ( *out_size == 0 || rsp_size == 0 )        *out_size = 0;
     else
         *out_size = (rsp_size < *out_size) ? rsp_size : *out_size;
 
     return ret;
 }
 
-static inline uint32_t tpm12_submit_cmd(uint32_t locality, uint32_t cmd,
-                                        uint32_t arg_size, uint32_t *out_size)
+static inline uint32_t tpm12_submit_cmd(uint32_t locality, uint32_t cmd, uint32_t arg_size, uint32_t *out_size)
 {
-   return  _tpm12_submit_cmd(locality, TPM_TAG_RQU_COMMAND, cmd,
-                             arg_size, out_size);
+   return  _tpm12_submit_cmd(locality, TPM_TAG_RQU_COMMAND, cmd, arg_size, out_size);
 }
 
 static inline uint32_t tpm12_submit_cmd_auth1(uint32_t locality, uint32_t cmd,
diff --git a/tboot/common/tpm_20.c b/tboot/common/tpm_20.c
index 4992849..eb3a487 100644
--- a/tboot/common/tpm_20.c
+++ b/tboot/common/tpm_20.c
@@ -51,6 +51,7 @@
 #include <mle.h>
 #include <txt/acmod.h>
 
+extern uint8_t g_tpm_family;
 static u8 cmd_buf[MAX_COMMAND_SIZE];
 static u8 rsp_buf[MAX_RESPONSE_SIZE];
 
@@ -68,17 +69,14 @@ static void reverse_copy_header(u32 cmd_code, TPM_CMD_SESSIONS_IN *sessions_in)
 {
     u16 tag;
 
-    if (sessions_in == NULL || sessions_in->num_sessions == 0)
-        tag = TPM_ST_NO_SESSIONS;
-    else
-        tag = TPM_ST_SESSIONS;
+    if (sessions_in == NULL || sessions_in->num_sessions == 0)  tag = TPM_ST_NO_SESSIONS;
+    else tag = TPM_ST_SESSIONS;
 
     reverse_copy(cmd_buf, &tag, sizeof(tag));
     reverse_copy(cmd_buf + CMD_CC_OFFSET, &cmd_code, sizeof(cmd_code));
 }
 
-static void reverse_copy_pcr_selection_in(void **other,
-                                          TPML_PCR_SELECTION *pcr_selection)
+static void reverse_copy_pcr_selection_in(void **other, TPML_PCR_SELECTION *pcr_selection)
 {
     u32 i, k;
 
@@ -93,18 +91,15 @@ static void reverse_copy_pcr_selection_in(void **other,
         reverse_copy_in(*other, pcr_selection->selections[i].size_of_select);
 
         /* Copy bit field of the PCRs selected. */
-        for (k=0; k<pcr_selection->selections[i].size_of_select; k++)
-            reverse_copy_in(*other, pcr_selection->selections[i].pcr_select[k]);
+        for (k=0; k<pcr_selection->selections[i].size_of_select; k++) reverse_copy_in(*other, pcr_selection->selections[i].pcr_select[k]);
     }
 }
 
-static void reverse_copy_pcr_selection_out(TPML_PCR_SELECTION *pcr_selection,
-                                           void **other)
+static void reverse_copy_pcr_selection_out(TPML_PCR_SELECTION *pcr_selection, void **other)
 {
     u32 i, k;
 
-    if (pcr_selection == NULL)
-        return;
+    if (pcr_selection == NULL)  return;
 
     /* Copy count of pcrs to be read. */
     reverse_copy_out(pcr_selection->count, *other);
@@ -149,12 +144,10 @@ static u16 reverse_copy_sized_buf_in(TPM2B *dest, TPM2B *src)
 {
     int i;
 
-    if (dest == NULL || src == NULL)
-        return 0;
+    if (dest == NULL || src == NULL)        return 0;
 
     reverse_copy(&dest->size, &src->size, sizeof(u16));
-    for (i=0; i<src->size; i++)
-        dest->buffer[i] = src->buffer[i];
+    for (i=0; i<src->size; i++) dest->buffer[i] = src->buffer[i];
 
     return sizeof(u16) + src->size;
 }
@@ -163,12 +156,10 @@ static u16 reverse_copy_sized_buf_out(TPM2B *dest, TPM2B *src)
 {
     int i;
 
-    if (dest == NULL || src == NULL)
-        return 0;
+    if (dest == NULL || src == NULL)   return 0;
 
     reverse_copy(&dest->size, &src->size, sizeof(u16));
-    for (i=0; i<dest->size; i++)
-        dest->buffer[i] = src->buffer[i];
+    for (i=0; i<dest->size; i++)        dest->buffer[i] = src->buffer[i];
 
     return sizeof(u16) + dest->size;
 }
@@ -177,23 +168,16 @@ static void reverse_copy_digest_out(TPML_DIGEST *tpml_digest, void **other)
 {
     u32 i;
 
-    if (tpml_digest == NULL)
-        return;
+    if (tpml_digest == NULL)        return;
 
     reverse_copy_out(tpml_digest->count, *other);
 
-    for (i=0; i<tpml_digest->count; i++)
-        *other += reverse_copy_sized_buf_out((TPM2B *)&(tpml_digest->digests[i]),
-                (TPM2B *)*other);
+    for (i=0; i<tpml_digest->count; i++)        *other += reverse_copy_sized_buf_out((TPM2B *)&(tpml_digest->digests[i]),  (TPM2B *)*other);
 }
 
-static void reverse_copy_session_data_in(void **other,
-                                         TPM_CMD_SESSION_DATA_IN *session_data,
-                                         u32 *session_size)
+static void reverse_copy_session_data_in(void **other, TPM_CMD_SESSION_DATA_IN *session_data, u32 *session_size)
 {
-    *session_size += sizeof(u32) + sizeof( u16 ) +
-        session_data->nonce.t.size + sizeof( u8 ) +
-        sizeof( u16 ) + session_data->hmac.t.size;
+    *session_size += sizeof(u32) + sizeof( u16 ) + session_data->nonce.t.size + sizeof( u8 ) + sizeof( u16 ) + session_data->hmac.t.size;
 
     /* copy session handle */
     reverse_copy_in(*other, session_data->session_handle);
@@ -215,16 +199,12 @@ static void reverse_copy_sessions_in(void **other, TPM_CMD_SESSIONS_IN *sessions
     u32 session_size = 0;
     void *session_size_ptr = *other;
 
-    if (sessions_in == NULL)
-        return;
+    if (sessions_in == NULL)  return;
 
     if (sessions_in->num_sessions != 0) {
-        *other += sizeof(u32);
-        for (i=0; i<sessions_in->num_sessions; i++)
-            reverse_copy_session_data_in(other,
-                    &sessions_in->sessions[i], &session_size);
+        *other += sizeof(u32);//handle size
+        for (i=0; i<sessions_in->num_sessions; i++)  reverse_copy_session_data_in(other, &sessions_in->sessions[i], &session_size);
     }
-
     reverse_copy(session_size_ptr, &session_size, sizeof(u32));
 }
 
@@ -305,13 +285,11 @@ static void reverse_copy_digest_value_in(void **other, TPML_DIGEST_VALUES *tpml_
     }
 }
 
-static void reverse_copy_digest_values_out(TPML_DIGEST_VALUES *tpml_digest,
-                                           void **other)
+static void reverse_copy_digest_values_out(TPML_DIGEST_VALUES *tpml_digest, void **other)
 {
     unsigned int i, k, num_bytes;
 
-    if (tpml_digest == NULL)
-        return;
+    if (tpml_digest == NULL)  return;
 
     reverse_copy_out(tpml_digest->count, *other);
 
@@ -908,9 +886,7 @@ static void reverse_copy_ticket_out(TPMT_TK_CREATION *ticket, void **other)
     *other += reverse_copy_sized_buf_out((TPM2B *)&(ticket->digest), (TPM2B *)*other);
 }
 
-static uint32_t _tpm20_pcr_read(u32 locality,
-                                tpm_pcr_read_in *in,
-                                tpm_pcr_read_out *out)
+static uint32_t _tpm20_pcr_read(u32 locality, tpm_pcr_read_in *in, tpm_pcr_read_out *out)
 {
     u32 ret;
     u32 cmd_size, rsp_size;
@@ -927,9 +903,13 @@ static uint32_t _tpm20_pcr_read(u32 locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) ) {
-        return TPM_RC_FAILURE;
-    }
+
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
+
+
+//	if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )         return TPM_RC_FAILURE;
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -973,8 +953,11 @@ static uint32_t _tpm20_pcr_extend(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+	    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
+
+ //   if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -990,15 +973,15 @@ static uint32_t _tpm20_pcr_extend(uint32_t locality,
     return ret;
 }
 
-static uint32_t _tpm20_pcr_event(uint32_t locality,
-                                 tpm_pcr_event_in *in,
-                                 tpm_pcr_event_out *out)
+static uint32_t _tpm20_pcr_event(uint32_t locality, tpm_pcr_event_in *in, tpm_pcr_event_out *out)
 {
     u32 ret;
     u32 cmd_size, rsp_size;
     u16 rsp_tag;
     void *other;
+	
     
+    printk(TBOOT_INFO"_tpm20_pcr_event is entered. \n");
     reverse_copy_header(TPM_CC_PCR_Event, &in->sessions);
 
     other = (void *)cmd_buf + CMD_HEAD_SIZE;
@@ -1013,28 +996,39 @@ static uint32_t _tpm20_pcr_event(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+    printk(TBOOT_INFO"command size is 0x%x\n", cmd_size);
+    printk(TBOOT_INFO"response size is 0x%x\n", rsp_size);
+    
+    if (g_tpm_family == TPM_IF_20_FIFO) {
+	if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  
+	    return TPM_RC_FAILURE;
+    }
+
+    if (g_tpm_family == TPM_IF_20_CRB) {
+	if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  {
+    	printk(TBOOT_INFO"tpm_submit_cmd_crb failed\n");
+	return TPM_RC_FAILURE;
+	}
+    }
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
-    if ( ret != TPM_RC_SUCCESS )
-        return ret;
+    if ( ret != TPM_RC_SUCCESS )  {
+		printk(TBOOT_INFO"reverse copy failed, 0x%08X \n", ret); 
+		return ret;
+    }
 
     other = (void *)rsp_buf + RSP_HEAD_SIZE;
     reverse_copy(&rsp_tag, rsp_buf, sizeof(rsp_tag));
-    if (rsp_tag == TPM_ST_SESSIONS)
-        other += sizeof(u32);
+    if (rsp_tag == TPM_ST_SESSIONS)  other += sizeof(u32);
 
     reverse_copy_digest_values_out(&out->digests, &other);
 
     reverse_copy_sessions_out(&out->sessions, other, rsp_tag, &in->sessions);
-
+    printk(TBOOT_INFO"_tpm20_pcr_event is exited. \n");
     return ret;
 }
 
-static uint32_t _tpm20_pcr_reset(uint32_t locality,
-                                 tpm_pcr_reset_in *in,
-                                 tpm_pcr_reset_out *out)
+static uint32_t _tpm20_pcr_reset(uint32_t locality,  tpm_pcr_reset_in *in, tpm_pcr_reset_out *out)
 {
     u32 ret;
     u32 cmd_size, rsp_size;
@@ -1054,17 +1048,18 @@ static uint32_t _tpm20_pcr_reset(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+ //   if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;
+     if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
+
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
-    if ( ret != TPM_RC_SUCCESS )
-        return ret;
+    if ( ret != TPM_RC_SUCCESS )        return ret;
 
     other = (void *)rsp_buf + RSP_HEAD_SIZE;
     reverse_copy(&rsp_tag, rsp_buf, sizeof(rsp_tag));
-    if (rsp_tag == TPM_ST_SESSIONS)
-        other += sizeof(u32);
+    if (rsp_tag == TPM_ST_SESSIONS)        other += sizeof(u32);
 
     reverse_copy_sessions_out(&out->sessions, other, rsp_tag, &in->sessions);
 
@@ -1092,8 +1087,12 @@ static uint32_t _tpm20_sequence_start(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = RSP_HEAD_SIZE + sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+
+   // if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1133,8 +1132,11 @@ static uint32_t _tpm20_sequence_update(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+  //  if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
+
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1175,8 +1177,11 @@ static uint32_t _tpm20_sequence_complete(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+   // if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+       if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
+
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1219,8 +1224,11 @@ static uint32_t _tpm20_nv_read(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+//    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
+
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1264,8 +1272,11 @@ static uint32_t _tpm20_nv_write(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+	
+  //  if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1300,8 +1311,10 @@ static uint32_t _tpm20_nv_read_public(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+   // if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1345,8 +1358,14 @@ static uint32_t _tpm20_get_random(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+   // if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {
+        printk(TBOOT_INFO"_tpm20_get_random call CRB_INF tpm_submit_cmd_crb() with locality = 0x%x\n", locality);
+		if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	
+    }
+
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1378,8 +1397,12 @@ static uint32_t _tpm20_shutdown(uint32_t locality, u16 type)
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = RSP_HEAD_SIZE; 
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+	
+  //  if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
+
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     return ret;
@@ -1387,9 +1410,7 @@ static uint32_t _tpm20_shutdown(uint32_t locality, u16 type)
 
 static __data u32 handle2048 = 0;
 static const char auth_str[] = "test";
-static uint32_t _tpm20_create_primary(uint32_t locality,
-                                     tpm_create_primary_in *in,
-                                     tpm_create_primary_out *out)
+static uint32_t _tpm20_create_primary(uint32_t locality, tpm_create_primary_in *in, tpm_create_primary_out *out)
 {
     u32 ret;
     u32 cmd_size, rsp_size;
@@ -1408,10 +1429,8 @@ static uint32_t _tpm20_create_primary(uint32_t locality,
     /* Copy inSensitive */
     sensitive_size_ptr = other;
     other += sizeof(u16);
-    other += reverse_copy_sized_buf_in((TPM2B *)other,
-            (TPM2B *)&(in->sensitive.t.sensitive.user_auth));
-    other += reverse_copy_sized_buf_in((TPM2B *)other,
-            (TPM2B *)&(in->sensitive.t.sensitive.data));
+    other += reverse_copy_sized_buf_in((TPM2B *)other, (TPM2B *)&(in->sensitive.t.sensitive.user_auth));
+    other += reverse_copy_sized_buf_in((TPM2B *)other, (TPM2B *)&(in->sensitive.t.sensitive.data));
     sensitive_size = (u8 *)other - (u8 *)sensitive_size_ptr - sizeof(u16);
     reverse_copy(sensitive_size_ptr, &sensitive_size, sizeof(u16));
 
@@ -1429,12 +1448,13 @@ static uint32_t _tpm20_create_primary(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
-    if ( ret != TPM_RC_SUCCESS )
-        return ret;
+    if ( ret != TPM_RC_SUCCESS )  return ret;
 
     other = (void *)rsp_buf + RSP_HEAD_SIZE;
 
@@ -1442,8 +1462,7 @@ static uint32_t _tpm20_create_primary(uint32_t locality,
     reverse_copy_out(out->obj_handle, other);
 
     reverse_copy(&rsp_tag, rsp_buf, sizeof(rsp_tag));
-    if (rsp_tag == TPM_ST_SESSIONS)
-        other += sizeof(u32);
+    if (rsp_tag == TPM_ST_SESSIONS)      other += sizeof(u32);
 
     /* Save outPublic */
     reverse_copy_public_out(&out->public, &other);
@@ -1452,8 +1471,7 @@ static uint32_t _tpm20_create_primary(uint32_t locality,
     reverse_copy_creation_data_out(&(out->creation_data), &other);
 
     /* Save creationHash */
-    other += reverse_copy_sized_buf_out((TPM2B *)&(out->creation_hash),
-            (TPM2B *)other);
+    other += reverse_copy_sized_buf_out((TPM2B *)&(out->creation_hash),  (TPM2B *)other);
 
     /* Save creationTicket */
     reverse_copy_ticket_out(&(out->creation_ticket), &other);
@@ -1466,9 +1484,7 @@ static uint32_t _tpm20_create_primary(uint32_t locality,
 }
 
 
-static uint32_t _tpm20_create(uint32_t locality,
-                              tpm_create_in *in,
-                              tpm_create_out *out)
+static uint32_t _tpm20_create(uint32_t locality,    tpm_create_in *in,     tpm_create_out *out)
 {
     u32 ret;
     u32 cmd_size, rsp_size;
@@ -1508,8 +1524,12 @@ static uint32_t _tpm20_create(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+
+    if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+
+    if (g_tpm_family == TPM_IF_20_CRB) {
+              printk(TBOOT_INFO"_tpm20_create call CRB_INF tpm_submit_cmd_crb() with locality = 0x%x\n", locality);
+		if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1541,9 +1561,7 @@ static uint32_t _tpm20_create(uint32_t locality,
     return ret;
 }
 
-static uint32_t _tpm20_load(uint32_t locality,
-                            tpm_load_in *in,
-                            tpm_load_out *out)
+static uint32_t _tpm20_load(uint32_t locality, tpm_load_in *in, tpm_load_out *out)
 {
     u32 ret;
     u32 cmd_size, rsp_size;
@@ -1566,8 +1584,17 @@ static uint32_t _tpm20_load(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+
+    if (g_tpm_family == TPM_IF_20_FIFO) {
+	if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  
+	    return TPM_RC_FAILURE;
+    }
+
+    if (g_tpm_family == TPM_IF_20_CRB) {
+        if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  
+	     return TPM_RC_FAILURE;
+    }
+
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1609,8 +1636,11 @@ static uint32_t _tpm20_unseal(uint32_t locality,
     reverse_copy(cmd_buf + CMD_SIZE_OFFSET, &cmd_size, sizeof(cmd_size));
 
     rsp_size = sizeof(*out);
-    if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )
-        return TPM_RC_FAILURE;
+   // if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )        return TPM_RC_FAILURE;
+       if (g_tpm_family == TPM_IF_20_FIFO) {if ( !tpm_submit_cmd(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;}
+//for CRB
+    if (g_tpm_family == TPM_IF_20_CRB) {if ( !tpm_submit_cmd_crb(locality, cmd_buf, cmd_size, rsp_buf, &rsp_size) )  return TPM_RC_FAILURE;	}
+
 
     reverse_copy(&ret, rsp_buf + RSP_RST_OFFSET, sizeof(ret));
     if ( ret != TPM_RC_SUCCESS )
@@ -1664,9 +1694,7 @@ static bool tpm20_pcr_read(struct tpm_if *ti, uint32_t locality,
         return false;
     }
 
-    copy_hash(out,
-            (tb_hash_t *)&(read_out.pcr_values.digests[0].t.buffer[0]),
-            ti->cur_alg);
+    copy_hash(out,            (tb_hash_t *)&(read_out.pcr_values.digests[0].t.buffer[0]),            ti->cur_alg);
 
     return true;
 }
@@ -1836,9 +1864,7 @@ static bool tpm20_nv_read(struct tpm_if *ti, uint32_t locality,
     return true;
 }
 
-static bool tpm20_nv_write(struct tpm_if *ti, uint32_t locality,
-                           uint32_t index, uint32_t offset,
-                           const uint8_t *data, uint32_t data_size)
+static bool tpm20_nv_write(struct tpm_if *ti, uint32_t locality, uint32_t index, uint32_t offset, const uint8_t *data, uint32_t data_size)
 {
     tpm_nv_write_in write_in;
     tpm_nv_write_out write_out;
@@ -1908,9 +1934,7 @@ static bool tpm20_get_nvindex_permission(struct tpm_if *ti, uint32_t locality,
     return true;
 }
 
-static bool tpm20_seal(struct tpm_if *ti, uint32_t locality,
-                       uint32_t in_data_size, const uint8_t *in_data,
-                       uint32_t *sealed_data_size, uint8_t *sealed_data)
+static bool tpm20_seal(struct tpm_if *ti, uint32_t locality, uint32_t in_data_size, const uint8_t *in_data, uint32_t *sealed_data_size, uint8_t *sealed_data)
 {
     tpm_create_in create_in; 
     tpm_create_out create_out; 
@@ -1933,11 +1957,9 @@ static bool tpm20_seal(struct tpm_if *ti, uint32_t locality,
     create_in.public.t.public_area.unique.keyed_hash.t.size = 0;
 
     create_in.sensitive.t.sensitive.user_auth.t.size = sizeof(auth_str) - 1;
-    memcpy(&(create_in.sensitive.t.sensitive.user_auth.t.buffer[0]),
-            auth_str, sizeof(auth_str)-1);
+    memcpy(&(create_in.sensitive.t.sensitive.user_auth.t.buffer[0]),  auth_str, sizeof(auth_str)-1);
     create_in.sensitive.t.sensitive.data.t.size = in_data_size;
-    memcpy(&(create_in.sensitive.t.sensitive.data.t.buffer[0]),
-            in_data, in_data_size); 
+    memcpy(&(create_in.sensitive.t.sensitive.data.t.buffer[0]), in_data, in_data_size); 
 
     create_in.outside_info.t.size = 0;
     create_in.creation_pcr.count = 0;
@@ -1948,15 +1970,14 @@ static bool tpm20_seal(struct tpm_if *ti, uint32_t locality,
         ti->error = ret;
         return false;
     }
+    printk(TBOOT_WARN"TPM: Create successful, return value = %08X\n", ret);
     *sealed_data_size = sizeof(create_out);
     memcpy(sealed_data, &create_out, *sealed_data_size); 
 
     return true;
 }
 
-static bool tpm20_unseal(struct tpm_if *ti, uint32_t locality,
-                         uint32_t sealed_data_size, const uint8_t *sealed_data,
-                         uint32_t *secret_size, uint8_t *secret)
+static bool tpm20_unseal(struct tpm_if *ti, uint32_t locality, uint32_t sealed_data_size, const uint8_t *sealed_data, uint32_t *secret_size, uint8_t *secret)
 {
     tpm_load_in load_in; 
     tpm_load_out load_out; 
@@ -2044,28 +2065,24 @@ static bool tpm20_get_random(struct tpm_if *ti, uint32_t locality,
 
     /* if TPM doesn't return all requested random bytes, try one more time */
     if ( out_size < requested_size ) {
-        printk(TBOOT_WARN"requested %x random bytes but only got %x\n", requested_size,
-               out_size);
+        printk(TBOOT_WARN"requested 0x%x random bytes but only got 0x%x\n", requested_size, out_size);
         /* we're only going to try twice */
         if ( first_attempt ) {
             first_attempt = false;
             uint32_t second_size = requested_size - out_size;
-            printk(TBOOT_WARN"trying one more time to get remaining %x bytes\n",
-                    second_size);
+            printk(TBOOT_WARN"trying one more time to get remaining 0x%x bytes\n", second_size);
             random_in.bytes_req = second_size;
 
             ret = _tpm20_get_random(locality, &random_in, &random_out);
             if ( ret != TPM_RC_SUCCESS ) {
-                printk(TBOOT_WARN"TPM: get random %u bytes, return value = %08X\n",
-                        *data_size, ret);
+                printk(TBOOT_WARN"TPM: get random 0x%x bytes, return failed value = 0x%08X\n", *data_size, ret);
                 ti->error = ret;
                 return false;
             }
-
+            printk(TBOOT_WARN"TPM: get random 0x%x bytes, return successful value = 0x%08X\n", *data_size, ret);
             out_size = random_out.random_bytes.t.size;
             if (out_size > 0)
-                memcpy(random_data+*data_size, 
-                        &(random_out.random_bytes.t.buffer[0]), out_size);
+                memcpy(random_data+*data_size, &(random_out.random_bytes.t.buffer[0]), out_size);
             *data_size += out_size;
         }
     }
@@ -2130,8 +2147,7 @@ static bool tpm20_cap_pcrs(struct tpm_if *ti, u32 locality, int pcr)
 static bool alg_is_supported(u16 alg)
 {
     for (int i=0; i<2; i++) {
-        if (alg == tboot_alg_list[i])
-            return true;
+        if (alg == tboot_alg_list[i])    return true;
     }
 
     return false;
@@ -2142,8 +2158,11 @@ static bool tpm20_init(struct tpm_if *ti)
     u32 ret;
     unsigned int i;
 
-    if ( ti == NULL )
-        return false;
+    if ( ti == NULL )  return false;
+    if (!txt_is_launched())
+		ti->cur_loc = 0;
+     else 
+	 	ti->cur_loc = 2;
 
     /* init version */
     ti->major = TPM20_VER_MAJOR;
@@ -2167,10 +2186,10 @@ static bool tpm20_init(struct tpm_if *ti)
     /* create one common password sesson*/
     create_pw_session(&pw_session);
 
-    /* init supported alg list for banks */
+    /* init tpm supported alg list for banks */
     tpm_pcr_event_in event_in;
     tpm_pcr_event_out event_out;
-    event_in.pcr_handle = 16;
+    event_in.pcr_handle = 16; //PCR16 debug pcr
     event_in.sessions.num_sessions = 1;
     event_in.sessions.sessions[0] = pw_session;
     event_in.data.t.size = 4;
@@ -2178,11 +2197,12 @@ static bool tpm20_init(struct tpm_if *ti)
     event_in.data.t.buffer[1] = 0xff;
     event_in.data.t.buffer[2] = 0x55;
     event_in.data.t.buffer[3] = 0xaa;
-    ret = _tpm20_pcr_event(0, &event_in, &event_out);
+    ret = _tpm20_pcr_event(ti->cur_loc, &event_in, &event_out);
+	
     if (ret != TPM_RC_SUCCESS) {
-        printk(TBOOT_WARN"TPM: PcrEvent return value = %08X\n", ret);
+        printk(TBOOT_WARN"TPM: PcrEvent not successful, return value = %08X\n", ret);
         ti->error = ret;
-        return false;
+        //return false;
     }
     ti->banks = event_out.digests.count;
     printk(TBOOT_INFO"TPM: supported bank count = %d\n", ti->banks);
@@ -2199,17 +2219,16 @@ static bool tpm20_init(struct tpm_if *ti)
             ti->alg_count++;
         }
     }
-    printk(TBOOT_INFO"TPM: supported alg count = %08X\n", ti->alg_count);
-    for (unsigned int i=0; i<ti->alg_count; i++)
-        printk(TBOOT_INFO"\t\t %08X\n", ti->algs[i]);
+    printk(TBOOT_INFO"TPM: tboot supported TPM alg count = %d\n", ti->alg_count);
+    for (unsigned int i=0; i<ti->alg_count; i++)   printk(TBOOT_INFO"\t\t %08X\n", ti->algs[i]);
 
-    if (handle2048 != 0)
-        goto out;
+// if handle already created, goto out
+    if (handle2048 != 0)  goto out;
 
     /* create primary object as parent obj for seal */
     tpm_create_primary_in primary_in;
     tpm_create_primary_out primary_out;
-    primary_in.primary_handle = TPM_RH_NULL;
+    primary_in.primary_handle = TPM_RH_NULL;//null hierarchy
     primary_in.sessions.num_sessions = 1;
     primary_in.sessions.sessions[0].session_handle = TPM_RS_PW;
     primary_in.sessions.sessions[0].nonce.t.size = 0;
@@ -2242,10 +2261,10 @@ static bool tpm20_init(struct tpm_if *ti)
     primary_in.outside_info.t.size = 0;
     primary_in.creation_pcr.count = 0;
     
-    printk(TBOOT_DETA"TPM:CreatePrimary creating hierarchy handle = %08X\n", primary_in.primary_handle);
-    ret = _tpm20_create_primary(0, &primary_in, &primary_out);
+    printk(TBOOT_DETA"TPM: CreatePrimary creating hierarchy handle = %08X\n", primary_in.primary_handle);
+    ret = _tpm20_create_primary(ti->cur_loc, &primary_in, &primary_out);
     if (ret != TPM_RC_SUCCESS) {
-        printk(TBOOT_WARN"TPM: CreatePrimary return value = %08X\n", ret);
+        printk(TBOOT_WARN"TPM: CreatePrimary not successful, return value = %08X\n", ret);
         ti->error = ret;
         return false;
     }
diff --git a/tboot/include/pci_cfgreg.h b/tboot/include/pci_cfgreg.h
old mode 100755
new mode 100644
diff --git a/tboot/include/tpm.h b/tboot/include/tpm.h
index a81cc9e..e0cb71f 100644
--- a/tboot/include/tpm.h
+++ b/tboot/include/tpm.h
@@ -44,6 +44,14 @@
 /* un-comment to enable detailed command tracing */
 //#define TPM_TRACE
 
+#define TPM_IF_12 0
+#define TPM_IF_20_FIFO 1
+#define TPM_IF_20_CRB 2
+
+#define TPM_INTERFACE_ID_FIFO_20  0x0
+#define TPM_INTERFACE_ID_CRB     0x1
+#define TPM_INTERFACE_ID_FIFO_13   0xF
+
 #define TPM_LOCALITY_BASE             0xfed40000
 #define TPM_LOCALITY_0                TPM_LOCALITY_BASE
 #define TPM_LOCALITY_1                (TPM_LOCALITY_BASE | 0x1000)
@@ -52,9 +60,17 @@
 #define TPM_LOCALITY_4                (TPM_LOCALITY_BASE | 0x4000)
 #define TPM_LOCALITY_BASE_N(n)        (TPM_LOCALITY_BASE | ((n) << 12))
 #define TPM_NR_LOCALITIES             5
-#define NR_TPM_LOCALITY_PAGES         ((TPM_LOCALITY_1 - TPM_LOCALITY_0) >> \
-                                       PAGE_SHIFT)
-
+#define NR_TPM_LOCALITY_PAGES         ((TPM_LOCALITY_1 - TPM_LOCALITY_0) >> PAGE_SHIFT)
+
+#define TPM_LOCALITY_CRB_BASE        0xfed40000
+#define TPM_LOCALITY_CRB_0                TPM_LOCALITY_CRB_BASE
+#define TPM_LOCALITY_CRB_1                (TPM_LOCALITY_CRB_BASE | 0x1000)
+#define TPM_LOCALITY_CRB_2                (TPM_LOCALITY_CRB_BASE | 0x2000)
+#define TPM_LOCALITY_CRB_3                (TPM_LOCALITY_CRB_BASE | 0x3000)
+#define TPM_LOCALITY_CRB_4                (TPM_LOCALITY_CRB_BASE | 0x4000)
+#define TPM_LOCALITY_CRB_BASE_N(n)        (TPM_LOCALITY_CRB_BASE | ((n) << 12))
+#define TPM_NR_CRB_LOCALITIES             5
+#define NR_TPM_LOCALITY_CRB_PAGES         ((TPM_LOCALITY_CRB_1 - TPM_LOCALITY_CRB_0) >> PAGE_SHIFT)
 /*
  * Command Header Fields:
  *       0   1   2   3   4   5   6   7   8   9   10  ...
@@ -139,35 +155,246 @@ typedef struct __packed {
 #define TPM_ALG_MAX_NUM           (TPM_ALG_LAST - TPM_ALG_ERROR)
 
 
+// move from tpm.c
+
+/*
+ * TPM registers and data structures
+ *
+ * register values are offsets from each locality base
+ * see {read,write}_tpm_reg() for data struct format
+ */
+
+/* TPM_ACCESS_x */
+#define TPM_REG_ACCESS           0x00
+#define TPM_REG_STS              0x18
+
+typedef union {
+    u8 _raw[1];                      /* 1-byte reg */
+    struct __packed {
+        u8 tpm_establishment   : 1;  /* RO, 0=T/OS has been established
+                                        before */
+        u8 request_use         : 1;  /* RW, 1=locality is requesting TPM use */
+        u8 pending_request     : 1;  /* RO, 1=other locality is requesting
+                                        TPM usage */
+        u8 seize               : 1;  /* WO, 1=seize locality */
+        u8 been_seized         : 1;  /* RW, 1=locality seized while active */
+        u8 active_locality     : 1;  /* RW, 1=locality is active */
+        u8 reserved            : 1;
+        u8 tpm_reg_valid_sts   : 1;  /* RO, 1=other bits are valid */
+    };
+} tpm_reg_access_t;
+
+/* TPM_STS_x */
+
+typedef union {
+    u8 _raw[3];                  /* 3-byte reg */
+    struct __packed {
+        u8 reserved1       : 1;
+        u8 response_retry  : 1;  /* WO, 1=re-send response */
+        u8 self_test_done  : 1;  /* RO, only for version 2 */
+        u8 expect          : 1;  /* RO, 1=more data for command expected */
+        u8 data_avail      : 1;  /* RO, 0=no more data for response */
+        u8 tpm_go          : 1;  /* WO, 1=execute sent command */
+        u8 command_ready   : 1;  /* RW, 1=TPM ready to receive new cmd */
+        u8 sts_valid       : 1;  /* RO, 1=data_avail and expect bits are  valid */
+        u16 burst_count    : 16; /* RO, # read/writes bytes before wait */
+    };
+} tpm12_reg_sts_t;
+
+typedef union {
+    u8 _raw[4];                  /* 4-byte reg */
+    struct __packed {
+        u8 reserved1       : 1;
+        u8 response_retry  : 1;  /* WO, 1=re-send response */
+        u8 self_test_done  : 1;  /* RO, only for version 2 */
+        u8 expect          : 1;  /* RO, 1=more data for command expected */
+        u8 data_avail      : 1;  /* RO, 0=no more data for response */
+        u8 tpm_go          : 1;  /* WO, 1=execute sent command */
+        u8 command_ready   : 1;  /* RW, 1=TPM ready to receive new cmd */
+        u8 sts_valid       : 1;  /* RO, 1=data_avail and expect bits are
+                                    valid */
+        u16 burst_count    : 16; /* RO, # read/writes bytes before wait */
+        /* version >= 2 */
+        u8 command_cancel       : 1;
+        u8 reset_establishment  : 1;
+        u8 tpm_family           : 2;
+        u8 reserved2            : 4;
+    };
+} tpm20_reg_sts_t;
+
+//-----------------------------------------------------------------------------
+// CRB I/F related definitions, see TCG PC Client Platform TPM Profile (PTP) Specification, Level 00 Revision 00.43
+//-----------------------------------------------------------------------------
+#define TPM_REG_LOC_STATE           0x00
+#define TPM_REG_LOC_CTRL              0x8
+#define TPM_LOCALITY_STS         0x0C
+#define TPM_INTERFACE_ID        0x30
+#define TPM_CONTROL_AREA       0x40
+#define TPM_CRB_CTRL_REQ              0x40
+#define TPM_CRB_CTRL_STS  0x44
+#define TPM_CRB_CTRL_CANCEL 0x48
+#define TPM_CRB_CTRL_START 0x4C
+#define TPM_CRB_CTRL_CMD_SIZE 0x58
+#define TPM_CRB_CTRL_CMD_ADDR 0x5C
+#define TPM_CRB_CTRL_CMD_HADDR 0x60
+#define TPM_CRB_CTRL_RSP_SIZE 0x64
+#define TPM_CRB_CTRL_RSP_ADDR 0x68
+#define TPM_CRB_DATA_BUFFER 0x80
+#define TPMCRBBUF_LEN      0xF80     //3968 Bytes
+
+//#define CTRL_AREA_ADDR  (uint32_t) (TPM_CRB_BASE + 0x40) 
+//#define DATA_BUF_ADDR   (uint32_t) (TPM_CRB_BASE + 0x80)
+ 
+typedef union {
+    u8 _raw[4];                      /* 4-byte reg */
+    struct __packed {
+        u8 tpm_establishment   : 1;  
+        u8 loc_assigned         : 1;  
+        u8 active_locality     : 3;  
+        u8 reserved              : 2; 
+        u8 tpm_reg_valid_sts   : 1;  /* RO, 1=other bits are valid */
+	u8 reserved1                   :8;
+        u16 reserved2                :16;	
+    };
+} tpm_reg_loc_state_t;
+
+typedef union {
+   uint8_t _raw[4];
+   struct __packed {
+   uint32_t  requestAccess:1;
+   uint32_t  relinquish:1;
+   uint32_t  seize:1;
+   uint32_t  resetEstablishment:1;
+   uint32_t  reserved1:28;
+   };
+} tpm_reg_loc_ctrl_t;
+
+typedef union {
+	uint8_t _raw[4];
+	struct __packed{
+		uint32_t  Granted:1;
+		uint32_t  BeenSeized:1;
+		uint32_t  R:30;
+	};
+} tpm_reg_loc_sts_t;
+
+typedef union {
+   uint8_t _raw[8];        // 8-byte reg
+   struct __packed {
+        uint64_t  interface_type:4;
+        uint64_t  interface_version:4;
+        uint64_t  interface_capability:4;
+        uint64_t  interface_selector:4;
+        uint64_t  rid:8;
+        uint64_t  res:8;
+        uint64_t  vid:16;
+        uint64_t  did:16;
+   };
+} tpm_crb_interface_id_t;
+
+typedef union {
+   uint8_t _raw[4];
+   struct __packed{
+   	   uint32_t  cmdReady:1;   
+	   uint32_t  goIdle:1;
+	   uint32_t  Reserved:30;
+   };
+ } tpm_reg_ctrl_request_t;
+
+typedef union {
+	uint8_t _raw[4];
+	struct  __packed{
+		uint32_t  tpmsts:1;
+		uint32_t  tpmidle:1;
+		uint32_t  reserved:30;
+	};
+} tpm_reg_ctrl_sts_t;
+
+typedef union {
+	uint8_t _raw[4];
+	struct  __packed{
+		uint32_t  start;
+	};
+} tpm_reg_ctrl_start_t;
+
+typedef union {
+	uint8_t _raw[4];
+	struct  __packed{
+		uint32_t  cancel;
+	};
+} tpm_reg_ctrl_cancel_t;
+
+typedef union {
+	uint8_t _raw[8];
+	struct  __packed{
+		uint32_t  cmdladdr;
+		uint32_t  cmdhaddr;
+	};
+} tpm_reg_ctrl_cmdaddr_t;
+
+typedef union {
+	uint8_t _raw[4];
+	struct  __packed{
+		uint32_t  cmdsize;
+	};
+} tpm_reg_ctrl_cmdsize_t;
+
+typedef union {
+	uint8_t _raw[8];
+	struct  __packed{
+		uint64_t  rspaddr;
+	};
+} tpm_reg_ctrl_rspaddr_t;
+
+typedef union {
+	uint8_t _raw[4];
+	struct  __packed{
+		uint32_t  rspsize;
+	};
+} tpm_reg_ctrl_rspsize_t;
+
+typedef union {
+	uint8_t _raw[48];
+	struct __packed {
+		tpm_reg_ctrl_request_t  Request;
+		tpm_reg_ctrl_sts_t    Status;
+		tpm_reg_ctrl_cancel_t    Cancel;
+		tpm_reg_ctrl_start_t  Start;
+		uint64_t  R;
+		tpm_reg_ctrl_cmdsize_t  CmdSize;
+		tpm_reg_ctrl_cmdaddr_t  CmdAddr;
+		tpm_reg_ctrl_rspsize_t  RspSize;
+		tpm_reg_ctrl_rspaddr_t  RspAddr;
+	};
+} tpm_ctrl_area_t;
+
+// END OF CRB I/F 
+
 /*
  * assumes that all reg types follow above format:
  *   - packed
  *   - member named '_raw' which is array whose size is that of data to read
  */
-#define read_tpm_reg(locality, reg, pdata)      \
-    _read_tpm_reg(locality, reg, (pdata)->_raw, sizeof(*(pdata)))
+#define read_tpm_reg(locality, reg, pdata)   _read_tpm_reg(locality, reg, (pdata)->_raw, sizeof(*(pdata)))
 
-#define write_tpm_reg(locality, reg, pdata)     \
-    _write_tpm_reg(locality, reg, (pdata)->_raw, sizeof(*(pdata)))
+#define write_tpm_reg(locality, reg, pdata)   _write_tpm_reg(locality, reg, (pdata)->_raw, sizeof(*(pdata)))
 
 static inline void _read_tpm_reg(int locality, u32 reg, u8 *_raw, size_t size)
 {
-    for ( size_t i = 0; i < size; i++ )
-        _raw[i] = readb((TPM_LOCALITY_BASE_N(locality) | reg) + i);
+    for ( size_t i = 0; i < size; i++ )   _raw[i] = readb((TPM_LOCALITY_BASE_N(locality) | reg) + i);
 }
 
 static inline void _write_tpm_reg(int locality, u32 reg, u8 *_raw, size_t size)
 {
-    for ( size_t i = 0; i < size; i++ )
-        writeb((TPM_LOCALITY_BASE_N(locality) | reg) + i, _raw[i]);
+    for ( size_t i = 0; i < size; i++ )  writeb((TPM_LOCALITY_BASE_N(locality) | reg) + i, _raw[i]);
 }
 
+
 /*
  * the following inline function reversely copy the bytes from 'in' to
  * 'out', the byte number to copy is given in count.
  */
-#define reverse_copy(out, in, count) \
-    _reverse_copy((uint8_t *)(out), (uint8_t *)(in), count)
+#define reverse_copy(out, in, count)     _reverse_copy((uint8_t *)(out), (uint8_t *)(in), count)
 
 static inline void _reverse_copy(uint8_t *out, uint8_t *in, uint32_t count)
 {
@@ -223,20 +450,14 @@ struct tpm_if {
 
     bool (*init)(struct tpm_if *ti);
 
-    bool (*pcr_read)(struct tpm_if *ti, u32 locality, u32 pcr,
-            tpm_pcr_value_t *out);
-    bool (*pcr_extend)(struct tpm_if *ti, u32 locality, u32 pcr,
-            const hash_list_t *in);
+    bool (*pcr_read)(struct tpm_if *ti, u32 locality, u32 pcr, tpm_pcr_value_t *out);
+    bool (*pcr_extend)(struct tpm_if *ti, u32 locality, u32 pcr, const hash_list_t *in);
     bool (*pcr_reset)(struct tpm_if *ti, u32 locality, u32 pcr);
-    bool (*hash)(struct tpm_if *ti, u32 locality, const u8 *data,
-            u32 data_size, hash_list_t *hl);
+    bool (*hash)(struct tpm_if *ti, u32 locality, const u8 *data, u32 data_size, hash_list_t *hl);
 
-    bool (*nv_read)(struct tpm_if *ti, u32 locality, u32 index,
-            u32 offset, u8 *data, u32 *data_size);
-    bool (*nv_write)(struct tpm_if *ti, u32 locality, u32 index,
-            u32 offset, const u8 *data, u32 data_size);
-    bool (*get_nvindex_size)(struct tpm_if *ti, u32 locality,
-            u32 index, u32 *size);
+    bool (*nv_read)(struct tpm_if *ti, u32 locality, u32 index, u32 offset, u8 *data, u32 *data_size);
+    bool (*nv_write)(struct tpm_if *ti, u32 locality, u32 index, u32 offset, const u8 *data, u32 data_size);
+    bool (*get_nvindex_size)(struct tpm_if *ti, u32 locality, u32 index, u32 *size);
 
 #define TPM_NV_PER_WRITE_STCLEAR  (1<<14) 
 #define TPM_NV_PER_WRITEDEFINE    (1<<13)
@@ -244,18 +465,13 @@ struct tpm_if {
 #define TPM_NV_PER_AUTHWRITE      (1<<2)
 #define TPM_NV_PER_OWNERWRITE     (1<<1)
 #define TPM_NV_PER_PPWRITE        (1<<0)
-    bool (*get_nvindex_permission)(struct tpm_if *ti, u32 locality,
-            u32 index, u32 *attribute);
+    bool (*get_nvindex_permission)(struct tpm_if *ti, u32 locality, u32 index, u32 *attribute);
 
-    bool (*seal)(struct tpm_if *ti, u32 locality, u32 in_data_size,
-            const u8 *in_data, u32 *sealed_data_size, u8 *sealed_data);
-    bool (*unseal)(struct tpm_if *ti, u32 locality, u32 sealed_data_size,
-            const u8 *sealed_data, u32 *secret_size, u8 *secret);
-    bool (*verify_creation)(struct tpm_if *ti, u32 sealed_data_size,
-            u8 *sealed_data);
+    bool (*seal)(struct tpm_if *ti, u32 locality, u32 in_data_size, const u8 *in_data, u32 *sealed_data_size, u8 *sealed_data);
+    bool (*unseal)(struct tpm_if *ti, u32 locality, u32 sealed_data_size, const u8 *sealed_data, u32 *secret_size, u8 *secret);
+    bool (*verify_creation)(struct tpm_if *ti, u32 sealed_data_size, u8 *sealed_data);
 
-    bool (*get_random)(struct tpm_if *ti, u32 locality,
-            u8 *random_data, u32 *data_size);
+    bool (*get_random)(struct tpm_if *ti, u32 locality, u8 *random_data, u32 *data_size);
 
     uint32_t (*save_state)(struct tpm_if *ti, u32 locality);
 
@@ -266,14 +482,18 @@ struct tpm_if {
 extern struct tpm_if tpm_12_if;
 extern struct tpm_if tpm_20_if;
 extern struct tpm_if *g_tpm;
+extern uint8_t g_tpm_family;
 
 extern bool tpm_validate_locality(uint32_t locality);
+extern bool tpm_validate_locality_crb(uint32_t locality);
 extern bool release_locality(uint32_t locality);
 extern bool prepare_tpm(void);
 extern bool tpm_detect(void);
 extern void tpm_print(struct tpm_if *ti);
-extern bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size,
-        u8 *out, u32 *out_size);
+extern bool tpm_submit_cmd(u32 locality, u8 *in, u32 in_size, u8 *out, u32 *out_size);
+extern bool tpm_submit_cmd_crb(u32 locality, u8 *in, u32 in_size, u8 *out, u32 *out_size);
+extern bool tpm_relinquish_locality_crb(uint32_t locality);
+extern bool txt_is_launched(void);
 
 
 //#define TPM_UNIT_TEST 1
diff --git a/tboot/include/tpm_20.h b/tboot/include/tpm_20.h
index 4c835c3..8b3adb3 100644
--- a/tboot/include/tpm_20.h
+++ b/tboot/include/tpm_20.h
@@ -49,24 +49,19 @@ typedef struct {
 #define SHA1_DIGEST_SIZE    20
 #define SHA1_BLOCK_SIZE     64
 #define SHA1_DER_SIZE       15
-#define SHA1_DER            {0x30,0x21,0x30,0x09,0x06, \
-        0x05,0x2B,0x0E,0x03,0x02,0x1A,0x05,0x00,0x04,0x14}
+#define SHA1_DER            {0x30,0x21,0x30,0x09,0x06, 0x05,0x2B,0x0E,0x03,0x02,0x1A,0x05,0x00,0x04,0x14}
 
 // Table 206 -- SHA256 Hash Values
 #define SHA256_DIGEST_SIZE    32
 #define SHA256_BLOCK_SIZE     64
 #define SHA256_DER_SIZE       19
-#define SHA256_DER            {0x30,0x31,0x30,0x0d,0x06, \
-        0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,\
-        0x05,0x00,0x04,0x20}
+#define SHA256_DER            {0x30,0x31,0x30,0x0d,0x06, 0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01, 0x05,0x00,0x04,0x20}
 
 // Table 207 -- SHA384 Hash Values
 #define SHA384_DIGEST_SIZE    48
 #define SHA384_BLOCK_SIZE     128
 #define SHA384_DER_SIZE       19
-#define SHA384_DER            {0x30,0x41,0x30,0x0d,0x06, \
-        0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,\
-        0x05,0x00,0x04,0x30}
+#define SHA384_DER            {0x30,0x41,0x30,0x0d,0x06, 0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02, 0x05,0x00,0x04,0x30}
 
 
 // Table 208 -- SHA512 Hash Values
@@ -134,8 +129,8 @@ typedef struct {
 #define MAX_RSA_KEY_BYTES     ((MAX_RSA_KEY_BITS + 7) / 8)    // 256
 
 // Table 218 -- ECC Algorithm Constants
-#define ECC_CURVES            {\
-    TPM_ECC_NIST_P256,TPM_ECC_BN_P256,TPM_ECC_SM2_P256}#define    ECC_KEY_SIZES_BITS    {256}
+#define ECC_CURVES            {TPM_ECC_NIST_P256,TPM_ECC_BN_P256,TPM_ECC_SM2_P256}
+#define ECC_KEY_SIZES_BITS    {256}
 #define MAX_ECC_KEY_BITS      256
 #define MAX_ECC_KEY_BYTES     ((MAX_ECC_KEY_BITS + 7) / 8)    // 32
 
diff --git a/tboot/include/txt/acmod.h b/tboot/include/txt/acmod.h
index b19e543..6221108 100644
--- a/tboot/include/txt/acmod.h
+++ b/tboot/include/txt/acmod.h
@@ -74,7 +74,7 @@ typedef struct {
     uint8_t      rsa2048_pubkey[256];
     uint32_t     pub_exp;
     uint8_t      rsa2048_sig[256];
-    uint32_t     scratch[143];
+    uint32_t     scratch[143];//
     uint8_t      user_area[];
 } acm_hdr_t;
 extern acm_hdr_t *g_sinit;
diff --git a/tboot/include/vga.h b/tboot/include/vga.h
old mode 100755
new mode 100644
diff --git a/tboot/txt/acmod.c b/tboot/txt/acmod.c
index ced2281..17a7b7b 100644
--- a/tboot/txt/acmod.c
+++ b/tboot/txt/acmod.c
@@ -438,8 +438,7 @@ txt_caps_t get_sinit_capabilities(const acm_hdr_t* hdr)
     return info_table->capabilities;
 }
 
-static bool is_acmod(const void *acmod_base, uint32_t acmod_size, uint8_t *type,
-                     bool quiet)
+static bool is_acmod(const void *acmod_base, uint32_t acmod_size, uint8_t *type,                      bool quiet)
 {
     acm_hdr_t *acm_hdr = (acm_hdr_t *)acmod_base;
 
diff --git a/tboot/txt/txt.c b/tboot/txt/txt.c
index b33ef2b..ea945a5 100644
--- a/tboot/txt/txt.c
+++ b/tboot/txt/txt.c
@@ -88,6 +88,7 @@ extern void cpu_wakeup(uint32_t cpuid, uint32_t sipi_vec);
 extern void print_event(const tpm12_pcr_event_t *evt);
 extern void print_event_2(void *evt, uint16_t alg);
 
+
 /*
  * this is the structure whose addr we'll put in TXT heap
  * it needs to be within the MLE pages, so force it to the .text section
@@ -429,8 +430,7 @@ __data acm_hdr_t *g_sinit = 0;
 /*
  * sets up TXT heap
  */
-static txt_heap_t *init_txt_heap(void *ptab_base, acm_hdr_t *sinit,
-                                 loader_ctx *lctx)
+static txt_heap_t *init_txt_heap(void *ptab_base, acm_hdr_t *sinit, loader_ctx *lctx)
 {
     txt_heap_t *txt_heap;
     uint64_t *size;
@@ -718,7 +718,29 @@ tb_error_t txt_launch_environment(loader_ctx *lctx)
     if ( !set_mtrrs_for_acmod(g_sinit) )
         return TB_ERR_FATAL;
 
-    printk(TBOOT_INFO"executing GETSEC[SENTER]...\n");
+   /* deactivate current locality */
+   if (g_tpm_family == TPM_IF_20_CRB ) {
+       printk(TBOOT_INFO"Relinquish CRB localility 0 before executing GETSEC[SENTER]...\n");
+	if (!tpm_relinquish_locality_crb(0)){
+		printk(TBOOT_INFO"Relinquish CRB locality 0 failed...\n");
+		apply_policy(TB_ERR_TPM_NOT_READY) ;
+	}
+   }
+
+   /*{
+   tpm_reg_loc_ctrl_t    reg_loc_ctrl;
+   tpm_reg_loc_state_t  reg_loc_state;
+   
+   reg_loc_ctrl._raw[0] = 0;
+   reg_loc_ctrl.relinquish = 1;
+   write_tpm_reg(0, TPM_REG_LOC_CTRL, &reg_loc_ctrl);
+   printk(TBOOT_INFO"Relinquish CRB localility 0 before executing GETSEC[SENTER]...\n");
+   read_tpm_reg(0, TPM_REG_LOC_STATE, &reg_loc_state);
+   printk(TBOOT_INFO"CRB reg_loc_state.active_locality is 0x%x \n", reg_loc_state.active_locality);
+   printk(TBOOT_INFO"CRB reg_loc_state.loc_assigned is 0x%x \n", reg_loc_state.loc_assigned);
+   }*/
+   
+   printk(TBOOT_INFO"executing GETSEC[SENTER]...\n");
     /* (optionally) pause before executing GETSEC[SENTER] */
     if ( g_vga_delay > 0 )
         delay(g_vga_delay * 1000);
@@ -922,8 +944,7 @@ void txt_post_launch(void)
     /* restore pre-SENTER IA32_MISC_ENABLE_MSR (no verification needed)
        (do after AP wakeup so that if restored MSR has MWAIT clear it won't
        prevent wakeup) */
-    printk(TBOOT_DETA"saved IA32_MISC_ENABLE = 0x%08x\n",
-           os_mle_data->saved_misc_enable_msr);
+    printk(TBOOT_DETA"saved IA32_MISC_ENABLE = 0x%08x\n", os_mle_data->saved_misc_enable_msr);
     wrmsr(MSR_IA32_MISC_ENABLE, os_mle_data->saved_misc_enable_msr);
     if ( use_mwait() ) {
         /* set MONITOR/MWAIT support */
-- 
1.7.1

